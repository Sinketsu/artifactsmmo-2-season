// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AchievementSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AchievementSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("points")
		e.Int(s.Points)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("target")
		s.Target.Encode(e)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("current")
		e.Int(s.Current)
	}
	{
		e.FieldStart("completed_at")
		s.CompletedAt.Encode(e)
	}
}

var jsonFieldsNameOfAchievementSchema = [9]string{
	0: "name",
	1: "code",
	2: "description",
	3: "points",
	4: "type",
	5: "target",
	6: "total",
	7: "current",
	8: "completed_at",
}

// Decode decodes AchievementSchema from json.
func (s *AchievementSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementSchema to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "current":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Current = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "completed_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.CompletedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AchievementSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAchievementSchema) {
					name = jsonFieldsNameOfAchievementSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementSchemaCompletedAt as json.
func (s AchievementSchemaCompletedAt) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeAchievementSchemaCompletedAt:
		json.EncodeDateTime(e, s.DateTime)
	case NullAchievementSchemaCompletedAt:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes AchievementSchemaCompletedAt from json.
func (s *AchievementSchemaCompletedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementSchemaCompletedAt to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullAchievementSchemaCompletedAt
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeAchievementSchemaCompletedAt
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AchievementSchemaCompletedAt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementSchemaCompletedAt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementSchemaTarget as json.
func (s AchievementSchemaTarget) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringAchievementSchemaTarget:
		e.Str(s.String)
	case NullAchievementSchemaTarget:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes AchievementSchemaTarget from json.
func (s *AchievementSchemaTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementSchemaTarget to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullAchievementSchemaTarget
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringAchievementSchemaTarget
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AchievementSchemaTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementSchemaTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementSchemaType as json.
func (s AchievementSchemaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AchievementSchemaType from json.
func (s *AchievementSchemaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementSchemaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AchievementSchemaType(v) {
	case AchievementSchemaTypeCombatKill:
		*s = AchievementSchemaTypeCombatKill
	case AchievementSchemaTypeCombatDrop:
		*s = AchievementSchemaTypeCombatDrop
	case AchievementSchemaTypeCombatLevel:
		*s = AchievementSchemaTypeCombatLevel
	case AchievementSchemaTypeGathering:
		*s = AchievementSchemaTypeGathering
	case AchievementSchemaTypeCrafting:
		*s = AchievementSchemaTypeCrafting
	case AchievementSchemaTypeRecycling:
		*s = AchievementSchemaTypeRecycling
	case AchievementSchemaTypeTask:
		*s = AchievementSchemaTypeTask
	case AchievementSchemaTypeOther:
		*s = AchievementSchemaTypeOther
	default:
		*s = AchievementSchemaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AchievementSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveEventSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveEventSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("map")
		s.Map.Encode(e)
	}
	{
		e.FieldStart("previous_skin")
		e.Str(s.PreviousSkin)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
}

var jsonFieldsNameOfActiveEventSchema = [6]string{
	0: "name",
	1: "map",
	2: "previous_skin",
	3: "duration",
	4: "expiration",
	5: "created_at",
}

// Decode decodes ActiveEventSchema from json.
func (s *ActiveEventSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEventSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "map":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Map.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"map\"")
			}
		case "previous_skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PreviousSkin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_skin\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveEventSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveEventSchema) {
					name = jsonFieldsNameOfActiveEventSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveEventSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEventSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveEventSchemaMap) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveEventSchemaMap) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		e.Str(s.Skin)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfActiveEventSchemaMap = [5]string{
	0: "name",
	1: "skin",
	2: "x",
	3: "y",
	4: "content",
}

// Decode decodes ActiveEventSchemaMap from json.
func (s *ActiveEventSchemaMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEventSchemaMap to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Skin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "x":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveEventSchemaMap")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveEventSchemaMap) {
					name = jsonFieldsNameOfActiveEventSchemaMap[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveEventSchemaMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEventSchemaMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActiveEventSchemaMapContent as json.
func (s ActiveEventSchemaMapContent) Encode(e *jx.Encoder) {
	switch s.Type {
	case MapContentSchemaActiveEventSchemaMapContent:
		s.MapContentSchema.Encode(e)
	case NullActiveEventSchemaMapContent:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes ActiveEventSchemaMapContent from json.
func (s *ActiveEventSchemaMapContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEventSchemaMapContent to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullActiveEventSchemaMapContent
	case jx.Object:
		if err := s.MapContentSchema.Decode(d); err != nil {
			return err
		}
		s.Type = MapContentSchemaActiveEventSchemaMapContent
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActiveEventSchemaMapContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEventSchemaMapContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddAccountSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddAccountSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
}

var jsonFieldsNameOfAddAccountSchema = [3]string{
	0: "username",
	1: "password",
	2: "email",
}

// Decode decodes AddAccountSchema from json.
func (s *AddAccountSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddAccountSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddAccountSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddAccountSchema) {
					name = jsonFieldsNameOfAddAccountSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddAccountSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddAccountSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddCharacterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddCharacterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
}

var jsonFieldsNameOfAddCharacterSchema = [2]string{
	0: "name",
	1: "skin",
}

// Decode decodes AddCharacterSchema from json.
func (s *AddCharacterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCharacterSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddCharacterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddCharacterSchema) {
					name = jsonFieldsNameOfAddCharacterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddCharacterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCharacterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddCharacterSchemaSkin as json.
func (s AddCharacterSchemaSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddCharacterSchemaSkin from json.
func (s *AddCharacterSchemaSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCharacterSchemaSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddCharacterSchemaSkin(v) {
	case AddCharacterSchemaSkinMen1:
		*s = AddCharacterSchemaSkinMen1
	case AddCharacterSchemaSkinMen2:
		*s = AddCharacterSchemaSkinMen2
	case AddCharacterSchemaSkinMen3:
		*s = AddCharacterSchemaSkinMen3
	case AddCharacterSchemaSkinWomen1:
		*s = AddCharacterSchemaSkinWomen1
	case AddCharacterSchemaSkinWomen2:
		*s = AddCharacterSchemaSkinWomen2
	case AddCharacterSchemaSkinWomen3:
		*s = AddCharacterSchemaSkinWomen3
	default:
		*s = AddCharacterSchemaSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddCharacterSchemaSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCharacterSchemaSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnouncementSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnouncementSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfAnnouncementSchema = [2]string{
	0: "message",
	1: "created_at",
}

// Decode decodes AnnouncementSchema from json.
func (s *AnnouncementSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnouncementSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnouncementSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnouncementSchema) {
					name = jsonFieldsNameOfAnnouncementSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnouncementSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnouncementSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankExtensionTransactionResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankExtensionTransactionResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfBankExtensionTransactionResponseSchema = [1]string{
	0: "data",
}

// Decode decodes BankExtensionTransactionResponseSchema from json.
func (s *BankExtensionTransactionResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankExtensionTransactionResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankExtensionTransactionResponseSchema) {
					name = jsonFieldsNameOfBankExtensionTransactionResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankExtensionTransactionResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankExtensionTransactionSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankExtensionTransactionSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("transaction")
		s.Transaction.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfBankExtensionTransactionSchema = [3]string{
	0: "cooldown",
	1: "transaction",
	2: "character",
}

// Decode decodes BankExtensionTransactionSchema from json.
func (s *BankExtensionTransactionSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "transaction":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Transaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankExtensionTransactionSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankExtensionTransactionSchema) {
					name = jsonFieldsNameOfBankExtensionTransactionSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankExtensionTransactionSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankExtensionTransactionSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankExtensionTransactionSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBankExtensionTransactionSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes BankExtensionTransactionSchemaCharacter from json.
func (s *BankExtensionTransactionSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankExtensionTransactionSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankExtensionTransactionSchemaCharacter) {
					name = jsonFieldsNameOfBankExtensionTransactionSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankExtensionTransactionSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankExtensionTransactionSchemaCharacterSkin as json.
func (s BankExtensionTransactionSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankExtensionTransactionSchemaCharacterSkin from json.
func (s *BankExtensionTransactionSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankExtensionTransactionSchemaCharacterSkin(v) {
	case BankExtensionTransactionSchemaCharacterSkinMen1:
		*s = BankExtensionTransactionSchemaCharacterSkinMen1
	case BankExtensionTransactionSchemaCharacterSkinMen2:
		*s = BankExtensionTransactionSchemaCharacterSkinMen2
	case BankExtensionTransactionSchemaCharacterSkinMen3:
		*s = BankExtensionTransactionSchemaCharacterSkinMen3
	case BankExtensionTransactionSchemaCharacterSkinWomen1:
		*s = BankExtensionTransactionSchemaCharacterSkinWomen1
	case BankExtensionTransactionSchemaCharacterSkinWomen2:
		*s = BankExtensionTransactionSchemaCharacterSkinWomen2
	case BankExtensionTransactionSchemaCharacterSkinWomen3:
		*s = BankExtensionTransactionSchemaCharacterSkinWomen3
	default:
		*s = BankExtensionTransactionSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankExtensionTransactionSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankExtensionTransactionSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankExtensionTransactionSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfBankExtensionTransactionSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes BankExtensionTransactionSchemaCooldown from json.
func (s *BankExtensionTransactionSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankExtensionTransactionSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankExtensionTransactionSchemaCooldown) {
					name = jsonFieldsNameOfBankExtensionTransactionSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankExtensionTransactionSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankExtensionTransactionSchemaCooldownReason as json.
func (s BankExtensionTransactionSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankExtensionTransactionSchemaCooldownReason from json.
func (s *BankExtensionTransactionSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankExtensionTransactionSchemaCooldownReason(v) {
	case BankExtensionTransactionSchemaCooldownReasonMovement:
		*s = BankExtensionTransactionSchemaCooldownReasonMovement
	case BankExtensionTransactionSchemaCooldownReasonFight:
		*s = BankExtensionTransactionSchemaCooldownReasonFight
	case BankExtensionTransactionSchemaCooldownReasonCrafting:
		*s = BankExtensionTransactionSchemaCooldownReasonCrafting
	case BankExtensionTransactionSchemaCooldownReasonGathering:
		*s = BankExtensionTransactionSchemaCooldownReasonGathering
	case BankExtensionTransactionSchemaCooldownReasonBuyGe:
		*s = BankExtensionTransactionSchemaCooldownReasonBuyGe
	case BankExtensionTransactionSchemaCooldownReasonSellGe:
		*s = BankExtensionTransactionSchemaCooldownReasonSellGe
	case BankExtensionTransactionSchemaCooldownReasonDeleteItem:
		*s = BankExtensionTransactionSchemaCooldownReasonDeleteItem
	case BankExtensionTransactionSchemaCooldownReasonDepositBank:
		*s = BankExtensionTransactionSchemaCooldownReasonDepositBank
	case BankExtensionTransactionSchemaCooldownReasonWithdrawBank:
		*s = BankExtensionTransactionSchemaCooldownReasonWithdrawBank
	case BankExtensionTransactionSchemaCooldownReasonEquip:
		*s = BankExtensionTransactionSchemaCooldownReasonEquip
	case BankExtensionTransactionSchemaCooldownReasonUnequip:
		*s = BankExtensionTransactionSchemaCooldownReasonUnequip
	case BankExtensionTransactionSchemaCooldownReasonTask:
		*s = BankExtensionTransactionSchemaCooldownReasonTask
	case BankExtensionTransactionSchemaCooldownReasonRecycling:
		*s = BankExtensionTransactionSchemaCooldownReasonRecycling
	default:
		*s = BankExtensionTransactionSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankExtensionTransactionSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankExtensionTransactionSchemaTransaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankExtensionTransactionSchemaTransaction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("price")
		e.Int(s.Price)
	}
}

var jsonFieldsNameOfBankExtensionTransactionSchemaTransaction = [1]string{
	0: "price",
}

// Decode decodes BankExtensionTransactionSchemaTransaction from json.
func (s *BankExtensionTransactionSchemaTransaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionSchemaTransaction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "price":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Price = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankExtensionTransactionSchemaTransaction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankExtensionTransactionSchemaTransaction) {
					name = jsonFieldsNameOfBankExtensionTransactionSchemaTransaction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankExtensionTransactionSchemaTransaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionSchemaTransaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankGoldTransactionResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankGoldTransactionResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfBankGoldTransactionResponseSchema = [1]string{
	0: "data",
}

// Decode decodes BankGoldTransactionResponseSchema from json.
func (s *BankGoldTransactionResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankGoldTransactionResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankGoldTransactionResponseSchema) {
					name = jsonFieldsNameOfBankGoldTransactionResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankGoldTransactionResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankGoldTransactionSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankGoldTransactionSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("bank")
		s.Bank.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfBankGoldTransactionSchema = [3]string{
	0: "cooldown",
	1: "bank",
	2: "character",
}

// Decode decodes BankGoldTransactionSchema from json.
func (s *BankGoldTransactionSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "bank":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Bank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bank\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankGoldTransactionSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankGoldTransactionSchema) {
					name = jsonFieldsNameOfBankGoldTransactionSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankGoldTransactionSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankGoldTransactionSchemaBank) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankGoldTransactionSchemaBank) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfBankGoldTransactionSchemaBank = [1]string{
	0: "quantity",
}

// Decode decodes BankGoldTransactionSchemaBank from json.
func (s *BankGoldTransactionSchemaBank) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionSchemaBank to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quantity":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankGoldTransactionSchemaBank")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankGoldTransactionSchemaBank) {
					name = jsonFieldsNameOfBankGoldTransactionSchemaBank[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankGoldTransactionSchemaBank) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionSchemaBank) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankGoldTransactionSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankGoldTransactionSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBankGoldTransactionSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes BankGoldTransactionSchemaCharacter from json.
func (s *BankGoldTransactionSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankGoldTransactionSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankGoldTransactionSchemaCharacter) {
					name = jsonFieldsNameOfBankGoldTransactionSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankGoldTransactionSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankGoldTransactionSchemaCharacterSkin as json.
func (s BankGoldTransactionSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankGoldTransactionSchemaCharacterSkin from json.
func (s *BankGoldTransactionSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankGoldTransactionSchemaCharacterSkin(v) {
	case BankGoldTransactionSchemaCharacterSkinMen1:
		*s = BankGoldTransactionSchemaCharacterSkinMen1
	case BankGoldTransactionSchemaCharacterSkinMen2:
		*s = BankGoldTransactionSchemaCharacterSkinMen2
	case BankGoldTransactionSchemaCharacterSkinMen3:
		*s = BankGoldTransactionSchemaCharacterSkinMen3
	case BankGoldTransactionSchemaCharacterSkinWomen1:
		*s = BankGoldTransactionSchemaCharacterSkinWomen1
	case BankGoldTransactionSchemaCharacterSkinWomen2:
		*s = BankGoldTransactionSchemaCharacterSkinWomen2
	case BankGoldTransactionSchemaCharacterSkinWomen3:
		*s = BankGoldTransactionSchemaCharacterSkinWomen3
	default:
		*s = BankGoldTransactionSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankGoldTransactionSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankGoldTransactionSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankGoldTransactionSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfBankGoldTransactionSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes BankGoldTransactionSchemaCooldown from json.
func (s *BankGoldTransactionSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankGoldTransactionSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankGoldTransactionSchemaCooldown) {
					name = jsonFieldsNameOfBankGoldTransactionSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankGoldTransactionSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankGoldTransactionSchemaCooldownReason as json.
func (s BankGoldTransactionSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankGoldTransactionSchemaCooldownReason from json.
func (s *BankGoldTransactionSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankGoldTransactionSchemaCooldownReason(v) {
	case BankGoldTransactionSchemaCooldownReasonMovement:
		*s = BankGoldTransactionSchemaCooldownReasonMovement
	case BankGoldTransactionSchemaCooldownReasonFight:
		*s = BankGoldTransactionSchemaCooldownReasonFight
	case BankGoldTransactionSchemaCooldownReasonCrafting:
		*s = BankGoldTransactionSchemaCooldownReasonCrafting
	case BankGoldTransactionSchemaCooldownReasonGathering:
		*s = BankGoldTransactionSchemaCooldownReasonGathering
	case BankGoldTransactionSchemaCooldownReasonBuyGe:
		*s = BankGoldTransactionSchemaCooldownReasonBuyGe
	case BankGoldTransactionSchemaCooldownReasonSellGe:
		*s = BankGoldTransactionSchemaCooldownReasonSellGe
	case BankGoldTransactionSchemaCooldownReasonDeleteItem:
		*s = BankGoldTransactionSchemaCooldownReasonDeleteItem
	case BankGoldTransactionSchemaCooldownReasonDepositBank:
		*s = BankGoldTransactionSchemaCooldownReasonDepositBank
	case BankGoldTransactionSchemaCooldownReasonWithdrawBank:
		*s = BankGoldTransactionSchemaCooldownReasonWithdrawBank
	case BankGoldTransactionSchemaCooldownReasonEquip:
		*s = BankGoldTransactionSchemaCooldownReasonEquip
	case BankGoldTransactionSchemaCooldownReasonUnequip:
		*s = BankGoldTransactionSchemaCooldownReasonUnequip
	case BankGoldTransactionSchemaCooldownReasonTask:
		*s = BankGoldTransactionSchemaCooldownReasonTask
	case BankGoldTransactionSchemaCooldownReasonRecycling:
		*s = BankGoldTransactionSchemaCooldownReasonRecycling
	default:
		*s = BankGoldTransactionSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankGoldTransactionSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemTransactionResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemTransactionResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfBankItemTransactionResponseSchema = [1]string{
	0: "data",
}

// Decode decodes BankItemTransactionResponseSchema from json.
func (s *BankItemTransactionResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemTransactionResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemTransactionResponseSchema) {
					name = jsonFieldsNameOfBankItemTransactionResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemTransactionResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemTransactionSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemTransactionSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("item")
		s.Item.Encode(e)
	}
	{
		e.FieldStart("bank")
		e.ArrStart()
		for _, elem := range s.Bank {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfBankItemTransactionSchema = [4]string{
	0: "cooldown",
	1: "item",
	2: "bank",
	3: "character",
}

// Decode decodes BankItemTransactionSchema from json.
func (s *BankItemTransactionSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "item":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Item.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item\"")
			}
		case "bank":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Bank = make([]SimpleItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Bank = append(s.Bank, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bank\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemTransactionSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemTransactionSchema) {
					name = jsonFieldsNameOfBankItemTransactionSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemTransactionSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemTransactionSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemTransactionSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBankItemTransactionSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes BankItemTransactionSchemaCharacter from json.
func (s *BankItemTransactionSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemTransactionSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemTransactionSchemaCharacter) {
					name = jsonFieldsNameOfBankItemTransactionSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemTransactionSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemTransactionSchemaCharacterSkin as json.
func (s BankItemTransactionSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankItemTransactionSchemaCharacterSkin from json.
func (s *BankItemTransactionSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankItemTransactionSchemaCharacterSkin(v) {
	case BankItemTransactionSchemaCharacterSkinMen1:
		*s = BankItemTransactionSchemaCharacterSkinMen1
	case BankItemTransactionSchemaCharacterSkinMen2:
		*s = BankItemTransactionSchemaCharacterSkinMen2
	case BankItemTransactionSchemaCharacterSkinMen3:
		*s = BankItemTransactionSchemaCharacterSkinMen3
	case BankItemTransactionSchemaCharacterSkinWomen1:
		*s = BankItemTransactionSchemaCharacterSkinWomen1
	case BankItemTransactionSchemaCharacterSkinWomen2:
		*s = BankItemTransactionSchemaCharacterSkinWomen2
	case BankItemTransactionSchemaCharacterSkinWomen3:
		*s = BankItemTransactionSchemaCharacterSkinWomen3
	default:
		*s = BankItemTransactionSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankItemTransactionSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemTransactionSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemTransactionSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfBankItemTransactionSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes BankItemTransactionSchemaCooldown from json.
func (s *BankItemTransactionSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemTransactionSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemTransactionSchemaCooldown) {
					name = jsonFieldsNameOfBankItemTransactionSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemTransactionSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemTransactionSchemaCooldownReason as json.
func (s BankItemTransactionSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankItemTransactionSchemaCooldownReason from json.
func (s *BankItemTransactionSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankItemTransactionSchemaCooldownReason(v) {
	case BankItemTransactionSchemaCooldownReasonMovement:
		*s = BankItemTransactionSchemaCooldownReasonMovement
	case BankItemTransactionSchemaCooldownReasonFight:
		*s = BankItemTransactionSchemaCooldownReasonFight
	case BankItemTransactionSchemaCooldownReasonCrafting:
		*s = BankItemTransactionSchemaCooldownReasonCrafting
	case BankItemTransactionSchemaCooldownReasonGathering:
		*s = BankItemTransactionSchemaCooldownReasonGathering
	case BankItemTransactionSchemaCooldownReasonBuyGe:
		*s = BankItemTransactionSchemaCooldownReasonBuyGe
	case BankItemTransactionSchemaCooldownReasonSellGe:
		*s = BankItemTransactionSchemaCooldownReasonSellGe
	case BankItemTransactionSchemaCooldownReasonDeleteItem:
		*s = BankItemTransactionSchemaCooldownReasonDeleteItem
	case BankItemTransactionSchemaCooldownReasonDepositBank:
		*s = BankItemTransactionSchemaCooldownReasonDepositBank
	case BankItemTransactionSchemaCooldownReasonWithdrawBank:
		*s = BankItemTransactionSchemaCooldownReasonWithdrawBank
	case BankItemTransactionSchemaCooldownReasonEquip:
		*s = BankItemTransactionSchemaCooldownReasonEquip
	case BankItemTransactionSchemaCooldownReasonUnequip:
		*s = BankItemTransactionSchemaCooldownReasonUnequip
	case BankItemTransactionSchemaCooldownReasonTask:
		*s = BankItemTransactionSchemaCooldownReasonTask
	case BankItemTransactionSchemaCooldownReasonRecycling:
		*s = BankItemTransactionSchemaCooldownReasonRecycling
	default:
		*s = BankItemTransactionSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankItemTransactionSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemTransactionSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemTransactionSchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("subtype")
		e.Str(s.Subtype)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Craft.Set {
			e.FieldStart("craft")
			s.Craft.Encode(e)
		}
	}
}

var jsonFieldsNameOfBankItemTransactionSchemaItem = [8]string{
	0: "name",
	1: "code",
	2: "level",
	3: "type",
	4: "subtype",
	5: "description",
	6: "effects",
	7: "craft",
}

// Decode decodes BankItemTransactionSchemaItem from json.
func (s *BankItemTransactionSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchemaItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "subtype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subtype = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtype\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]ItemEffectSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemEffectSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "craft":
			if err := func() error {
				s.Craft.Reset()
				if err := s.Craft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craft\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemTransactionSchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemTransactionSchemaItem) {
					name = jsonFieldsNameOfBankItemTransactionSchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemTransactionSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemTransactionSchemaItemCraft as json.
func (s BankItemTransactionSchemaItemCraft) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaBankItemTransactionSchemaItemCraft:
		s.CraftSchema.Encode(e)
	case NullBankItemTransactionSchemaItemCraft:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes BankItemTransactionSchemaItemCraft from json.
func (s *BankItemTransactionSchemaItemCraft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchemaItemCraft to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullBankItemTransactionSchemaItemCraft
	case jx.Object:
		if err := s.CraftSchema.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaBankItemTransactionSchemaItemCraft
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankItemTransactionSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfBankResponseSchema = [1]string{
	0: "data",
}

// Decode decodes BankResponseSchema from json.
func (s *BankResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankResponseSchema) {
					name = jsonFieldsNameOfBankResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("slots")
		e.Int(s.Slots)
	}
	{
		e.FieldStart("expansions")
		e.Int(s.Expansions)
	}
	{
		e.FieldStart("next_expansion_cost")
		e.Int(s.NextExpansionCost)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
}

var jsonFieldsNameOfBankSchema = [4]string{
	0: "slots",
	1: "expansions",
	2: "next_expansion_cost",
	3: "gold",
}

// Decode decodes BankSchema from json.
func (s *BankSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slots":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Slots = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slots\"")
			}
		case "expansions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Expansions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expansions\"")
			}
		case "next_expansion_cost":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.NextExpansionCost = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_expansion_cost\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankSchema) {
					name = jsonFieldsNameOfBankSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BaseAchievementSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BaseAchievementSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("points")
		e.Int(s.Points)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("target")
		s.Target.Encode(e)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfBaseAchievementSchema = [7]string{
	0: "name",
	1: "code",
	2: "description",
	3: "points",
	4: "type",
	5: "target",
	6: "total",
}

// Decode decodes BaseAchievementSchema from json.
func (s *BaseAchievementSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseAchievementSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BaseAchievementSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBaseAchievementSchema) {
					name = jsonFieldsNameOfBaseAchievementSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BaseAchievementSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BaseAchievementSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BaseAchievementSchemaTarget as json.
func (s BaseAchievementSchemaTarget) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringBaseAchievementSchemaTarget:
		e.Str(s.String)
	case NullBaseAchievementSchemaTarget:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes BaseAchievementSchemaTarget from json.
func (s *BaseAchievementSchemaTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseAchievementSchemaTarget to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullBaseAchievementSchemaTarget
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringBaseAchievementSchemaTarget
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BaseAchievementSchemaTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BaseAchievementSchemaTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BaseAchievementSchemaType as json.
func (s BaseAchievementSchemaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BaseAchievementSchemaType from json.
func (s *BaseAchievementSchemaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseAchievementSchemaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BaseAchievementSchemaType(v) {
	case BaseAchievementSchemaTypeCombatKill:
		*s = BaseAchievementSchemaTypeCombatKill
	case BaseAchievementSchemaTypeCombatDrop:
		*s = BaseAchievementSchemaTypeCombatDrop
	case BaseAchievementSchemaTypeCombatLevel:
		*s = BaseAchievementSchemaTypeCombatLevel
	case BaseAchievementSchemaTypeGathering:
		*s = BaseAchievementSchemaTypeGathering
	case BaseAchievementSchemaTypeCrafting:
		*s = BaseAchievementSchemaTypeCrafting
	case BaseAchievementSchemaTypeRecycling:
		*s = BaseAchievementSchemaTypeRecycling
	case BaseAchievementSchemaTypeTask:
		*s = BaseAchievementSchemaTypeTask
	case BaseAchievementSchemaTypeOther:
		*s = BaseAchievementSchemaTypeOther
	default:
		*s = BaseAchievementSchemaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BaseAchievementSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BaseAchievementSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BaseachievementResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BaseachievementResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfBaseachievementResponseSchema = [1]string{
	0: "data",
}

// Decode decodes BaseachievementResponseSchema from json.
func (s *BaseachievementResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseachievementResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BaseachievementResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBaseachievementResponseSchema) {
					name = jsonFieldsNameOfBaseachievementResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BaseachievementResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BaseachievementResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChangePassword) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChangePassword) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfChangePassword = [1]string{
	0: "password",
}

// Decode decodes ChangePassword from json.
func (s *ChangePassword) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChangePassword to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "password":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChangePassword")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChangePassword) {
					name = jsonFieldsNameOfChangePassword[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChangePassword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChangePassword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("fight")
		s.Fight.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfCharacterFightDataSchema = [3]string{
	0: "cooldown",
	1: "fight",
	2: "character",
}

// Decode decodes CharacterFightDataSchema from json.
func (s *CharacterFightDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "fight":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Fight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fight\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchema) {
					name = jsonFieldsNameOfCharacterFightDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes CharacterFightDataSchemaCharacter from json.
func (s *CharacterFightDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaCharacter) {
					name = jsonFieldsNameOfCharacterFightDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterFightDataSchemaCharacterSkin as json.
func (s CharacterFightDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterFightDataSchemaCharacterSkin from json.
func (s *CharacterFightDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterFightDataSchemaCharacterSkin(v) {
	case CharacterFightDataSchemaCharacterSkinMen1:
		*s = CharacterFightDataSchemaCharacterSkinMen1
	case CharacterFightDataSchemaCharacterSkinMen2:
		*s = CharacterFightDataSchemaCharacterSkinMen2
	case CharacterFightDataSchemaCharacterSkinMen3:
		*s = CharacterFightDataSchemaCharacterSkinMen3
	case CharacterFightDataSchemaCharacterSkinWomen1:
		*s = CharacterFightDataSchemaCharacterSkinWomen1
	case CharacterFightDataSchemaCharacterSkinWomen2:
		*s = CharacterFightDataSchemaCharacterSkinWomen2
	case CharacterFightDataSchemaCharacterSkinWomen3:
		*s = CharacterFightDataSchemaCharacterSkinWomen3
	default:
		*s = CharacterFightDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterFightDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes CharacterFightDataSchemaCooldown from json.
func (s *CharacterFightDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaCooldown) {
					name = jsonFieldsNameOfCharacterFightDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterFightDataSchemaCooldownReason as json.
func (s CharacterFightDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterFightDataSchemaCooldownReason from json.
func (s *CharacterFightDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterFightDataSchemaCooldownReason(v) {
	case CharacterFightDataSchemaCooldownReasonMovement:
		*s = CharacterFightDataSchemaCooldownReasonMovement
	case CharacterFightDataSchemaCooldownReasonFight:
		*s = CharacterFightDataSchemaCooldownReasonFight
	case CharacterFightDataSchemaCooldownReasonCrafting:
		*s = CharacterFightDataSchemaCooldownReasonCrafting
	case CharacterFightDataSchemaCooldownReasonGathering:
		*s = CharacterFightDataSchemaCooldownReasonGathering
	case CharacterFightDataSchemaCooldownReasonBuyGe:
		*s = CharacterFightDataSchemaCooldownReasonBuyGe
	case CharacterFightDataSchemaCooldownReasonSellGe:
		*s = CharacterFightDataSchemaCooldownReasonSellGe
	case CharacterFightDataSchemaCooldownReasonDeleteItem:
		*s = CharacterFightDataSchemaCooldownReasonDeleteItem
	case CharacterFightDataSchemaCooldownReasonDepositBank:
		*s = CharacterFightDataSchemaCooldownReasonDepositBank
	case CharacterFightDataSchemaCooldownReasonWithdrawBank:
		*s = CharacterFightDataSchemaCooldownReasonWithdrawBank
	case CharacterFightDataSchemaCooldownReasonEquip:
		*s = CharacterFightDataSchemaCooldownReasonEquip
	case CharacterFightDataSchemaCooldownReasonUnequip:
		*s = CharacterFightDataSchemaCooldownReasonUnequip
	case CharacterFightDataSchemaCooldownReasonTask:
		*s = CharacterFightDataSchemaCooldownReasonTask
	case CharacterFightDataSchemaCooldownReasonRecycling:
		*s = CharacterFightDataSchemaCooldownReasonRecycling
	default:
		*s = CharacterFightDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterFightDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaFight) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaFight) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("drops")
		e.ArrStart()
		for _, elem := range s.Drops {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("turns")
		e.Int(s.Turns)
	}
	{
		e.FieldStart("monster_blocked_hits")
		s.MonsterBlockedHits.Encode(e)
	}
	{
		e.FieldStart("player_blocked_hits")
		s.PlayerBlockedHits.Encode(e)
	}
	{
		e.FieldStart("logs")
		e.ArrStart()
		for _, elem := range s.Logs {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaFight = [8]string{
	0: "xp",
	1: "gold",
	2: "drops",
	3: "turns",
	4: "monster_blocked_hits",
	5: "player_blocked_hits",
	6: "logs",
	7: "result",
}

// Decode decodes CharacterFightDataSchemaFight from json.
func (s *CharacterFightDataSchemaFight) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaFight to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "xp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "drops":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Drops = make([]DropSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Drops = append(s.Drops, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drops\"")
			}
		case "turns":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Turns = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turns\"")
			}
		case "monster_blocked_hits":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.MonsterBlockedHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monster_blocked_hits\"")
			}
		case "player_blocked_hits":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.PlayerBlockedHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_blocked_hits\"")
			}
		case "logs":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Logs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Logs = append(s.Logs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logs\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaFight")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaFight) {
					name = jsonFieldsNameOfCharacterFightDataSchemaFight[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaFight) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaFight) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fire")
		e.Int(s.Fire)
	}
	{
		e.FieldStart("earth")
		e.Int(s.Earth)
	}
	{
		e.FieldStart("water")
		e.Int(s.Water)
	}
	{
		e.FieldStart("air")
		e.Int(s.Air)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaFightMonsterBlockedHits = [5]string{
	0: "fire",
	1: "earth",
	2: "water",
	3: "air",
	4: "total",
}

// Decode decodes CharacterFightDataSchemaFightMonsterBlockedHits from json.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaFightMonsterBlockedHits to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fire":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Fire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fire\"")
			}
		case "earth":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Earth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"earth\"")
			}
		case "water":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Water = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"water\"")
			}
		case "air":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Air = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"air\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaFightMonsterBlockedHits")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaFightMonsterBlockedHits) {
					name = jsonFieldsNameOfCharacterFightDataSchemaFightMonsterBlockedHits[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fire")
		e.Int(s.Fire)
	}
	{
		e.FieldStart("earth")
		e.Int(s.Earth)
	}
	{
		e.FieldStart("water")
		e.Int(s.Water)
	}
	{
		e.FieldStart("air")
		e.Int(s.Air)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaFightPlayerBlockedHits = [5]string{
	0: "fire",
	1: "earth",
	2: "water",
	3: "air",
	4: "total",
}

// Decode decodes CharacterFightDataSchemaFightPlayerBlockedHits from json.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaFightPlayerBlockedHits to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fire":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Fire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fire\"")
			}
		case "earth":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Earth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"earth\"")
			}
		case "water":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Water = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"water\"")
			}
		case "air":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Air = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"air\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaFightPlayerBlockedHits")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaFightPlayerBlockedHits) {
					name = jsonFieldsNameOfCharacterFightDataSchemaFightPlayerBlockedHits[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterFightDataSchemaFightResult as json.
func (s CharacterFightDataSchemaFightResult) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterFightDataSchemaFightResult from json.
func (s *CharacterFightDataSchemaFightResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaFightResult to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterFightDataSchemaFightResult(v) {
	case CharacterFightDataSchemaFightResultWin:
		*s = CharacterFightDataSchemaFightResultWin
	case CharacterFightDataSchemaFightResultLose:
		*s = CharacterFightDataSchemaFightResultLose
	default:
		*s = CharacterFightDataSchemaFightResult(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterFightDataSchemaFightResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaFightResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCharacterFightResponseSchema = [1]string{
	0: "data",
}

// Decode decodes CharacterFightResponseSchema from json.
func (s *CharacterFightResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightResponseSchema) {
					name = jsonFieldsNameOfCharacterFightResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterLeaderboardSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterLeaderboardSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		e.Str(s.Skin)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_total_xp")
		e.Int(s.MiningTotalXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_total_xp")
		e.Int(s.WoodcuttingTotalXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_total_xp")
		e.Int(s.FishingTotalXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_total_xp")
		e.Int(s.WeaponcraftingTotalXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_total_xp")
		e.Int(s.GearcraftingTotalXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_total_xp")
		e.Int(s.JewelrycraftingTotalXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_total_xp")
		e.Int(s.CookingTotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
}

var jsonFieldsNameOfCharacterLeaderboardSchema = [20]string{
	0:  "name",
	1:  "skin",
	2:  "achievements_points",
	3:  "level",
	4:  "total_xp",
	5:  "mining_level",
	6:  "mining_total_xp",
	7:  "woodcutting_level",
	8:  "woodcutting_total_xp",
	9:  "fishing_level",
	10: "fishing_total_xp",
	11: "weaponcrafting_level",
	12: "weaponcrafting_total_xp",
	13: "gearcrafting_level",
	14: "gearcrafting_total_xp",
	15: "jewelrycrafting_level",
	16: "jewelrycrafting_total_xp",
	17: "cooking_level",
	18: "cooking_total_xp",
	19: "gold",
}

// Decode decodes CharacterLeaderboardSchema from json.
func (s *CharacterLeaderboardSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterLeaderboardSchema to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Skin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "mining_level":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_total_xp":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.MiningTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_total_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_total_xp":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_total_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_total_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.FishingTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_total_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_total_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_total_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_total_xp":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_total_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_total_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_total_xp\"")
			}
		case "cooking_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_total_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_total_xp\"")
			}
		case "gold":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterLeaderboardSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterLeaderboardSchema) {
					name = jsonFieldsNameOfCharacterLeaderboardSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterLeaderboardSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterLeaderboardSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("destination")
		s.Destination.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfCharacterMovementDataSchema = [3]string{
	0: "cooldown",
	1: "destination",
	2: "character",
}

// Decode decodes CharacterMovementDataSchema from json.
func (s *CharacterMovementDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "destination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Destination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementDataSchema) {
					name = jsonFieldsNameOfCharacterMovementDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCharacterMovementDataSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes CharacterMovementDataSchemaCharacter from json.
func (s *CharacterMovementDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementDataSchemaCharacter) {
					name = jsonFieldsNameOfCharacterMovementDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterMovementDataSchemaCharacterSkin as json.
func (s CharacterMovementDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterMovementDataSchemaCharacterSkin from json.
func (s *CharacterMovementDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterMovementDataSchemaCharacterSkin(v) {
	case CharacterMovementDataSchemaCharacterSkinMen1:
		*s = CharacterMovementDataSchemaCharacterSkinMen1
	case CharacterMovementDataSchemaCharacterSkinMen2:
		*s = CharacterMovementDataSchemaCharacterSkinMen2
	case CharacterMovementDataSchemaCharacterSkinMen3:
		*s = CharacterMovementDataSchemaCharacterSkinMen3
	case CharacterMovementDataSchemaCharacterSkinWomen1:
		*s = CharacterMovementDataSchemaCharacterSkinWomen1
	case CharacterMovementDataSchemaCharacterSkinWomen2:
		*s = CharacterMovementDataSchemaCharacterSkinWomen2
	case CharacterMovementDataSchemaCharacterSkinWomen3:
		*s = CharacterMovementDataSchemaCharacterSkinWomen3
	default:
		*s = CharacterMovementDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterMovementDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfCharacterMovementDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes CharacterMovementDataSchemaCooldown from json.
func (s *CharacterMovementDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementDataSchemaCooldown) {
					name = jsonFieldsNameOfCharacterMovementDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterMovementDataSchemaCooldownReason as json.
func (s CharacterMovementDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterMovementDataSchemaCooldownReason from json.
func (s *CharacterMovementDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterMovementDataSchemaCooldownReason(v) {
	case CharacterMovementDataSchemaCooldownReasonMovement:
		*s = CharacterMovementDataSchemaCooldownReasonMovement
	case CharacterMovementDataSchemaCooldownReasonFight:
		*s = CharacterMovementDataSchemaCooldownReasonFight
	case CharacterMovementDataSchemaCooldownReasonCrafting:
		*s = CharacterMovementDataSchemaCooldownReasonCrafting
	case CharacterMovementDataSchemaCooldownReasonGathering:
		*s = CharacterMovementDataSchemaCooldownReasonGathering
	case CharacterMovementDataSchemaCooldownReasonBuyGe:
		*s = CharacterMovementDataSchemaCooldownReasonBuyGe
	case CharacterMovementDataSchemaCooldownReasonSellGe:
		*s = CharacterMovementDataSchemaCooldownReasonSellGe
	case CharacterMovementDataSchemaCooldownReasonDeleteItem:
		*s = CharacterMovementDataSchemaCooldownReasonDeleteItem
	case CharacterMovementDataSchemaCooldownReasonDepositBank:
		*s = CharacterMovementDataSchemaCooldownReasonDepositBank
	case CharacterMovementDataSchemaCooldownReasonWithdrawBank:
		*s = CharacterMovementDataSchemaCooldownReasonWithdrawBank
	case CharacterMovementDataSchemaCooldownReasonEquip:
		*s = CharacterMovementDataSchemaCooldownReasonEquip
	case CharacterMovementDataSchemaCooldownReasonUnequip:
		*s = CharacterMovementDataSchemaCooldownReasonUnequip
	case CharacterMovementDataSchemaCooldownReasonTask:
		*s = CharacterMovementDataSchemaCooldownReasonTask
	case CharacterMovementDataSchemaCooldownReasonRecycling:
		*s = CharacterMovementDataSchemaCooldownReasonRecycling
	default:
		*s = CharacterMovementDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterMovementDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementDataSchemaDestination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementDataSchemaDestination) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		e.Str(s.Skin)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfCharacterMovementDataSchemaDestination = [5]string{
	0: "name",
	1: "skin",
	2: "x",
	3: "y",
	4: "content",
}

// Decode decodes CharacterMovementDataSchemaDestination from json.
func (s *CharacterMovementDataSchemaDestination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaDestination to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Skin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "x":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementDataSchemaDestination")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementDataSchemaDestination) {
					name = jsonFieldsNameOfCharacterMovementDataSchemaDestination[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementDataSchemaDestination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaDestination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterMovementDataSchemaDestinationContent as json.
func (s CharacterMovementDataSchemaDestinationContent) Encode(e *jx.Encoder) {
	switch s.Type {
	case MapContentSchemaCharacterMovementDataSchemaDestinationContent:
		s.MapContentSchema.Encode(e)
	case NullCharacterMovementDataSchemaDestinationContent:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes CharacterMovementDataSchemaDestinationContent from json.
func (s *CharacterMovementDataSchemaDestinationContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaDestinationContent to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullCharacterMovementDataSchemaDestinationContent
	case jx.Object:
		if err := s.MapContentSchema.Decode(d); err != nil {
			return err
		}
		s.Type = MapContentSchemaCharacterMovementDataSchemaDestinationContent
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterMovementDataSchemaDestinationContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaDestinationContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCharacterMovementResponseSchema = [1]string{
	0: "data",
}

// Decode decodes CharacterMovementResponseSchema from json.
func (s *CharacterMovementResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementResponseSchema) {
					name = jsonFieldsNameOfCharacterMovementResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCharacterResponseSchema = [1]string{
	0: "data",
}

// Decode decodes CharacterResponseSchema from json.
func (s *CharacterResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterResponseSchema) {
					name = jsonFieldsNameOfCharacterResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCharacterSchema = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes CharacterSchema from json.
func (s *CharacterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterSchema to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterSchema) {
					name = jsonFieldsNameOfCharacterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterSchemaSkin as json.
func (s CharacterSchemaSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterSchemaSkin from json.
func (s *CharacterSchemaSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterSchemaSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterSchemaSkin(v) {
	case CharacterSchemaSkinMen1:
		*s = CharacterSchemaSkinMen1
	case CharacterSchemaSkinMen2:
		*s = CharacterSchemaSkinMen2
	case CharacterSchemaSkinMen3:
		*s = CharacterSchemaSkinMen3
	case CharacterSchemaSkinWomen1:
		*s = CharacterSchemaSkinWomen1
	case CharacterSchemaSkinWomen2:
		*s = CharacterSchemaSkinWomen2
	case CharacterSchemaSkinWomen3:
		*s = CharacterSchemaSkinWomen3
	default:
		*s = CharacterSchemaSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterSchemaSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterSchemaSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CraftSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CraftSchema) encodeFields(e *jx.Encoder) {
	{
		if s.Skill.Set {
			e.FieldStart("skill")
			s.Skill.Encode(e)
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfCraftSchema = [4]string{
	0: "skill",
	1: "level",
	2: "items",
	3: "quantity",
}

// Decode decodes CraftSchema from json.
func (s *CraftSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CraftSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "skill":
			if err := func() error {
				s.Skill.Reset()
				if err := s.Skill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]SimpleItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CraftSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CraftSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CraftSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CraftSchemaSkill as json.
func (s CraftSchemaSkill) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CraftSchemaSkill from json.
func (s *CraftSchemaSkill) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CraftSchemaSkill to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CraftSchemaSkill(v) {
	case CraftSchemaSkillWeaponcrafting:
		*s = CraftSchemaSkillWeaponcrafting
	case CraftSchemaSkillGearcrafting:
		*s = CraftSchemaSkillGearcrafting
	case CraftSchemaSkillJewelrycrafting:
		*s = CraftSchemaSkillJewelrycrafting
	case CraftSchemaSkillCooking:
		*s = CraftSchemaSkillCooking
	case CraftSchemaSkillWoodcutting:
		*s = CraftSchemaSkillWoodcutting
	case CraftSchemaSkillMining:
		*s = CraftSchemaSkillMining
	default:
		*s = CraftSchemaSkill(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CraftSchemaSkill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CraftSchemaSkill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CraftingSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CraftingSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfCraftingSchema = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes CraftingSchema from json.
func (s *CraftingSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CraftingSchema to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CraftingSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCraftingSchema) {
					name = jsonFieldsNameOfCraftingSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CraftingSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CraftingSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageAchievementSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageAchievementSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageAchievementSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageAchievementSchema from json.
func (s *DataPageAchievementSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAchievementSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]AchievementSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AchievementSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageAchievementSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageAchievementSchema) {
					name = jsonFieldsNameOfDataPageAchievementSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageAchievementSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAchievementSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAchievementSchemaPage as json.
func (s DataPageAchievementSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAchievementSchemaPage:
		e.Int(s.Int)
	case NullDataPageAchievementSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAchievementSchemaPage from json.
func (s *DataPageAchievementSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAchievementSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAchievementSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAchievementSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAchievementSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAchievementSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAchievementSchemaPages as json.
func (s DataPageAchievementSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAchievementSchemaPages:
		e.Int(s.Int)
	case NullDataPageAchievementSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAchievementSchemaPages from json.
func (s *DataPageAchievementSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAchievementSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAchievementSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAchievementSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAchievementSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAchievementSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAchievementSchemaSize as json.
func (s DataPageAchievementSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAchievementSchemaSize:
		e.Int(s.Int)
	case NullDataPageAchievementSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAchievementSchemaSize from json.
func (s *DataPageAchievementSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAchievementSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAchievementSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAchievementSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAchievementSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAchievementSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAchievementSchemaTotal as json.
func (s DataPageAchievementSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAchievementSchemaTotal:
		e.Int(s.Int)
	case NullDataPageAchievementSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAchievementSchemaTotal from json.
func (s *DataPageAchievementSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAchievementSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAchievementSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAchievementSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAchievementSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAchievementSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageActiveEventSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageActiveEventSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageActiveEventSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageActiveEventSchema from json.
func (s *DataPageActiveEventSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageActiveEventSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]ActiveEventSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActiveEventSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageActiveEventSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageActiveEventSchema) {
					name = jsonFieldsNameOfDataPageActiveEventSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageActiveEventSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageActiveEventSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageActiveEventSchemaPage as json.
func (s DataPageActiveEventSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageActiveEventSchemaPage:
		e.Int(s.Int)
	case NullDataPageActiveEventSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageActiveEventSchemaPage from json.
func (s *DataPageActiveEventSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageActiveEventSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageActiveEventSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageActiveEventSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageActiveEventSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageActiveEventSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageActiveEventSchemaPages as json.
func (s DataPageActiveEventSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageActiveEventSchemaPages:
		e.Int(s.Int)
	case NullDataPageActiveEventSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageActiveEventSchemaPages from json.
func (s *DataPageActiveEventSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageActiveEventSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageActiveEventSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageActiveEventSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageActiveEventSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageActiveEventSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageActiveEventSchemaSize as json.
func (s DataPageActiveEventSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageActiveEventSchemaSize:
		e.Int(s.Int)
	case NullDataPageActiveEventSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageActiveEventSchemaSize from json.
func (s *DataPageActiveEventSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageActiveEventSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageActiveEventSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageActiveEventSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageActiveEventSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageActiveEventSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageActiveEventSchemaTotal as json.
func (s DataPageActiveEventSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageActiveEventSchemaTotal:
		e.Int(s.Int)
	case NullDataPageActiveEventSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageActiveEventSchemaTotal from json.
func (s *DataPageActiveEventSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageActiveEventSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageActiveEventSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageActiveEventSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageActiveEventSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageActiveEventSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageBaseAchievementSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageBaseAchievementSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageBaseAchievementSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageBaseAchievementSchema from json.
func (s *DataPageBaseAchievementSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageBaseAchievementSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]BaseAchievementSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BaseAchievementSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageBaseAchievementSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageBaseAchievementSchema) {
					name = jsonFieldsNameOfDataPageBaseAchievementSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageBaseAchievementSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageBaseAchievementSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageBaseAchievementSchemaPage as json.
func (s DataPageBaseAchievementSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageBaseAchievementSchemaPage:
		e.Int(s.Int)
	case NullDataPageBaseAchievementSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageBaseAchievementSchemaPage from json.
func (s *DataPageBaseAchievementSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageBaseAchievementSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageBaseAchievementSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageBaseAchievementSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageBaseAchievementSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageBaseAchievementSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageBaseAchievementSchemaPages as json.
func (s DataPageBaseAchievementSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageBaseAchievementSchemaPages:
		e.Int(s.Int)
	case NullDataPageBaseAchievementSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageBaseAchievementSchemaPages from json.
func (s *DataPageBaseAchievementSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageBaseAchievementSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageBaseAchievementSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageBaseAchievementSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageBaseAchievementSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageBaseAchievementSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageBaseAchievementSchemaSize as json.
func (s DataPageBaseAchievementSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageBaseAchievementSchemaSize:
		e.Int(s.Int)
	case NullDataPageBaseAchievementSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageBaseAchievementSchemaSize from json.
func (s *DataPageBaseAchievementSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageBaseAchievementSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageBaseAchievementSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageBaseAchievementSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageBaseAchievementSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageBaseAchievementSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageBaseAchievementSchemaTotal as json.
func (s DataPageBaseAchievementSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageBaseAchievementSchemaTotal:
		e.Int(s.Int)
	case NullDataPageBaseAchievementSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageBaseAchievementSchemaTotal from json.
func (s *DataPageBaseAchievementSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageBaseAchievementSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageBaseAchievementSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageBaseAchievementSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageBaseAchievementSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageBaseAchievementSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageCharacterLeaderboardSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageCharacterLeaderboardSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageCharacterLeaderboardSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageCharacterLeaderboardSchema from json.
func (s *DataPageCharacterLeaderboardSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterLeaderboardSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]CharacterLeaderboardSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CharacterLeaderboardSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageCharacterLeaderboardSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageCharacterLeaderboardSchema) {
					name = jsonFieldsNameOfDataPageCharacterLeaderboardSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageCharacterLeaderboardSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterLeaderboardSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterLeaderboardSchemaPage as json.
func (s DataPageCharacterLeaderboardSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterLeaderboardSchemaPage:
		e.Int(s.Int)
	case NullDataPageCharacterLeaderboardSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterLeaderboardSchemaPage from json.
func (s *DataPageCharacterLeaderboardSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterLeaderboardSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterLeaderboardSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterLeaderboardSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterLeaderboardSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterLeaderboardSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterLeaderboardSchemaPages as json.
func (s DataPageCharacterLeaderboardSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterLeaderboardSchemaPages:
		e.Int(s.Int)
	case NullDataPageCharacterLeaderboardSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterLeaderboardSchemaPages from json.
func (s *DataPageCharacterLeaderboardSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterLeaderboardSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterLeaderboardSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterLeaderboardSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterLeaderboardSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterLeaderboardSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterLeaderboardSchemaSize as json.
func (s DataPageCharacterLeaderboardSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterLeaderboardSchemaSize:
		e.Int(s.Int)
	case NullDataPageCharacterLeaderboardSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterLeaderboardSchemaSize from json.
func (s *DataPageCharacterLeaderboardSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterLeaderboardSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterLeaderboardSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterLeaderboardSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterLeaderboardSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterLeaderboardSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterLeaderboardSchemaTotal as json.
func (s DataPageCharacterLeaderboardSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterLeaderboardSchemaTotal:
		e.Int(s.Int)
	case NullDataPageCharacterLeaderboardSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterLeaderboardSchemaTotal from json.
func (s *DataPageCharacterLeaderboardSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterLeaderboardSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterLeaderboardSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterLeaderboardSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterLeaderboardSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterLeaderboardSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageCharacterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageCharacterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageCharacterSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageCharacterSchema from json.
func (s *DataPageCharacterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]CharacterSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CharacterSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageCharacterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageCharacterSchema) {
					name = jsonFieldsNameOfDataPageCharacterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageCharacterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterSchemaPage as json.
func (s DataPageCharacterSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterSchemaPage:
		e.Int(s.Int)
	case NullDataPageCharacterSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterSchemaPage from json.
func (s *DataPageCharacterSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterSchemaPages as json.
func (s DataPageCharacterSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterSchemaPages:
		e.Int(s.Int)
	case NullDataPageCharacterSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterSchemaPages from json.
func (s *DataPageCharacterSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterSchemaSize as json.
func (s DataPageCharacterSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterSchemaSize:
		e.Int(s.Int)
	case NullDataPageCharacterSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterSchemaSize from json.
func (s *DataPageCharacterSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterSchemaTotal as json.
func (s DataPageCharacterSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterSchemaTotal:
		e.Int(s.Int)
	case NullDataPageCharacterSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterSchemaTotal from json.
func (s *DataPageCharacterSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageGEItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageGEItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageGEItemSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageGEItemSchema from json.
func (s *DataPageGEItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]GEItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GEItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageGEItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageGEItemSchema) {
					name = jsonFieldsNameOfDataPageGEItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageGEItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEItemSchemaPage as json.
func (s DataPageGEItemSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGEItemSchemaPage:
		e.Int(s.Int)
	case NullDataPageGEItemSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGEItemSchemaPage from json.
func (s *DataPageGEItemSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEItemSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGEItemSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGEItemSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGEItemSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEItemSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEItemSchemaPages as json.
func (s DataPageGEItemSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGEItemSchemaPages:
		e.Int(s.Int)
	case NullDataPageGEItemSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGEItemSchemaPages from json.
func (s *DataPageGEItemSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEItemSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGEItemSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGEItemSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGEItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEItemSchemaSize as json.
func (s DataPageGEItemSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGEItemSchemaSize:
		e.Int(s.Int)
	case NullDataPageGEItemSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGEItemSchemaSize from json.
func (s *DataPageGEItemSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEItemSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGEItemSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGEItemSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGEItemSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEItemSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEItemSchemaTotal as json.
func (s DataPageGEItemSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGEItemSchemaTotal:
		e.Int(s.Int)
	case NullDataPageGEItemSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGEItemSchemaTotal from json.
func (s *DataPageGEItemSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEItemSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGEItemSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGEItemSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGEItemSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEItemSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageItemSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageItemSchema from json.
func (s *DataPageItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]ItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageItemSchema) {
					name = jsonFieldsNameOfDataPageItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaPage as json.
func (s DataPageItemSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageItemSchemaPage:
		e.Int(s.Int)
	case NullDataPageItemSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageItemSchemaPage from json.
func (s *DataPageItemSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageItemSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageItemSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageItemSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaPages as json.
func (s DataPageItemSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageItemSchemaPages:
		e.Int(s.Int)
	case NullDataPageItemSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageItemSchemaPages from json.
func (s *DataPageItemSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageItemSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageItemSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaSize as json.
func (s DataPageItemSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageItemSchemaSize:
		e.Int(s.Int)
	case NullDataPageItemSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageItemSchemaSize from json.
func (s *DataPageItemSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageItemSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageItemSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageItemSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaTotal as json.
func (s DataPageItemSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageItemSchemaTotal:
		e.Int(s.Int)
	case NullDataPageItemSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageItemSchemaTotal from json.
func (s *DataPageItemSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageItemSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageItemSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageItemSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageLogSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageLogSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageLogSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageLogSchema from json.
func (s *DataPageLogSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]LogSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LogSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageLogSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageLogSchema) {
					name = jsonFieldsNameOfDataPageLogSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageLogSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaPage as json.
func (s DataPageLogSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageLogSchemaPage:
		e.Int(s.Int)
	case NullDataPageLogSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageLogSchemaPage from json.
func (s *DataPageLogSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageLogSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageLogSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageLogSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaPages as json.
func (s DataPageLogSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageLogSchemaPages:
		e.Int(s.Int)
	case NullDataPageLogSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageLogSchemaPages from json.
func (s *DataPageLogSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageLogSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageLogSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageLogSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaSize as json.
func (s DataPageLogSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageLogSchemaSize:
		e.Int(s.Int)
	case NullDataPageLogSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageLogSchemaSize from json.
func (s *DataPageLogSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageLogSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageLogSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageLogSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaTotal as json.
func (s DataPageLogSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageLogSchemaTotal:
		e.Int(s.Int)
	case NullDataPageLogSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageLogSchemaTotal from json.
func (s *DataPageLogSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageLogSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageLogSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageLogSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageMapSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageMapSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageMapSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageMapSchema from json.
func (s *DataPageMapSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]MapSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MapSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageMapSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageMapSchema) {
					name = jsonFieldsNameOfDataPageMapSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageMapSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaPage as json.
func (s DataPageMapSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMapSchemaPage:
		e.Int(s.Int)
	case NullDataPageMapSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMapSchemaPage from json.
func (s *DataPageMapSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMapSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMapSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMapSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaPages as json.
func (s DataPageMapSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMapSchemaPages:
		e.Int(s.Int)
	case NullDataPageMapSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMapSchemaPages from json.
func (s *DataPageMapSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMapSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMapSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMapSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaSize as json.
func (s DataPageMapSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMapSchemaSize:
		e.Int(s.Int)
	case NullDataPageMapSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMapSchemaSize from json.
func (s *DataPageMapSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMapSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMapSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMapSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaTotal as json.
func (s DataPageMapSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMapSchemaTotal:
		e.Int(s.Int)
	case NullDataPageMapSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMapSchemaTotal from json.
func (s *DataPageMapSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMapSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMapSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMapSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageMonsterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageMonsterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageMonsterSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageMonsterSchema from json.
func (s *DataPageMonsterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]MonsterSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MonsterSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageMonsterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageMonsterSchema) {
					name = jsonFieldsNameOfDataPageMonsterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageMonsterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaPage as json.
func (s DataPageMonsterSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMonsterSchemaPage:
		e.Int(s.Int)
	case NullDataPageMonsterSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMonsterSchemaPage from json.
func (s *DataPageMonsterSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMonsterSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMonsterSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMonsterSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaPages as json.
func (s DataPageMonsterSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMonsterSchemaPages:
		e.Int(s.Int)
	case NullDataPageMonsterSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMonsterSchemaPages from json.
func (s *DataPageMonsterSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMonsterSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMonsterSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMonsterSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaSize as json.
func (s DataPageMonsterSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMonsterSchemaSize:
		e.Int(s.Int)
	case NullDataPageMonsterSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMonsterSchemaSize from json.
func (s *DataPageMonsterSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMonsterSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMonsterSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMonsterSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaTotal as json.
func (s DataPageMonsterSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMonsterSchemaTotal:
		e.Int(s.Int)
	case NullDataPageMonsterSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMonsterSchemaTotal from json.
func (s *DataPageMonsterSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMonsterSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMonsterSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMonsterSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageResourceSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageResourceSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageResourceSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageResourceSchema from json.
func (s *DataPageResourceSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]ResourceSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResourceSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageResourceSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageResourceSchema) {
					name = jsonFieldsNameOfDataPageResourceSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageResourceSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaPage as json.
func (s DataPageResourceSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageResourceSchemaPage:
		e.Int(s.Int)
	case NullDataPageResourceSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageResourceSchemaPage from json.
func (s *DataPageResourceSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageResourceSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageResourceSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageResourceSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaPages as json.
func (s DataPageResourceSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageResourceSchemaPages:
		e.Int(s.Int)
	case NullDataPageResourceSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageResourceSchemaPages from json.
func (s *DataPageResourceSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageResourceSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageResourceSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageResourceSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaSize as json.
func (s DataPageResourceSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageResourceSchemaSize:
		e.Int(s.Int)
	case NullDataPageResourceSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageResourceSchemaSize from json.
func (s *DataPageResourceSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageResourceSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageResourceSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageResourceSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaTotal as json.
func (s DataPageResourceSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageResourceSchemaTotal:
		e.Int(s.Int)
	case NullDataPageResourceSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageResourceSchemaTotal from json.
func (s *DataPageResourceSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageResourceSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageResourceSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageResourceSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageSimpleItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageSimpleItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageSimpleItemSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageSimpleItemSchema from json.
func (s *DataPageSimpleItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]SimpleItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageSimpleItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageSimpleItemSchema) {
					name = jsonFieldsNameOfDataPageSimpleItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageSimpleItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaPage as json.
func (s DataPageSimpleItemSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageSimpleItemSchemaPage:
		e.Int(s.Int)
	case NullDataPageSimpleItemSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageSimpleItemSchemaPage from json.
func (s *DataPageSimpleItemSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageSimpleItemSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageSimpleItemSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageSimpleItemSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaPages as json.
func (s DataPageSimpleItemSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageSimpleItemSchemaPages:
		e.Int(s.Int)
	case NullDataPageSimpleItemSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageSimpleItemSchemaPages from json.
func (s *DataPageSimpleItemSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageSimpleItemSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageSimpleItemSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageSimpleItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaSize as json.
func (s DataPageSimpleItemSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageSimpleItemSchemaSize:
		e.Int(s.Int)
	case NullDataPageSimpleItemSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageSimpleItemSchemaSize from json.
func (s *DataPageSimpleItemSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageSimpleItemSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageSimpleItemSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageSimpleItemSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaTotal as json.
func (s DataPageSimpleItemSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageSimpleItemSchemaTotal:
		e.Int(s.Int)
	case NullDataPageSimpleItemSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageSimpleItemSchemaTotal from json.
func (s *DataPageSimpleItemSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageSimpleItemSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageSimpleItemSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageSimpleItemSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageTaskFullSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageTaskFullSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageTaskFullSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageTaskFullSchema from json.
func (s *DataPageTaskFullSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTaskFullSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]TaskFullSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TaskFullSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageTaskFullSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageTaskFullSchema) {
					name = jsonFieldsNameOfDataPageTaskFullSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageTaskFullSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTaskFullSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTaskFullSchemaPage as json.
func (s DataPageTaskFullSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageTaskFullSchemaPage:
		e.Int(s.Int)
	case NullDataPageTaskFullSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageTaskFullSchemaPage from json.
func (s *DataPageTaskFullSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTaskFullSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageTaskFullSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageTaskFullSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageTaskFullSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTaskFullSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTaskFullSchemaPages as json.
func (s DataPageTaskFullSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageTaskFullSchemaPages:
		e.Int(s.Int)
	case NullDataPageTaskFullSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageTaskFullSchemaPages from json.
func (s *DataPageTaskFullSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTaskFullSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageTaskFullSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageTaskFullSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageTaskFullSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTaskFullSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTaskFullSchemaSize as json.
func (s DataPageTaskFullSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageTaskFullSchemaSize:
		e.Int(s.Int)
	case NullDataPageTaskFullSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageTaskFullSchemaSize from json.
func (s *DataPageTaskFullSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTaskFullSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageTaskFullSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageTaskFullSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageTaskFullSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTaskFullSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTaskFullSchemaTotal as json.
func (s DataPageTaskFullSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageTaskFullSchemaTotal:
		e.Int(s.Int)
	case NullDataPageTaskFullSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageTaskFullSchemaTotal from json.
func (s *DataPageTaskFullSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTaskFullSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageTaskFullSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageTaskFullSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageTaskFullSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTaskFullSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageTasksRewardFullSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageTasksRewardFullSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageTasksRewardFullSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageTasksRewardFullSchema from json.
func (s *DataPageTasksRewardFullSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTasksRewardFullSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]TasksRewardFullSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TasksRewardFullSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageTasksRewardFullSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageTasksRewardFullSchema) {
					name = jsonFieldsNameOfDataPageTasksRewardFullSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageTasksRewardFullSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTasksRewardFullSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTasksRewardFullSchemaPage as json.
func (s DataPageTasksRewardFullSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageTasksRewardFullSchemaPage:
		e.Int(s.Int)
	case NullDataPageTasksRewardFullSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageTasksRewardFullSchemaPage from json.
func (s *DataPageTasksRewardFullSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTasksRewardFullSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageTasksRewardFullSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageTasksRewardFullSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageTasksRewardFullSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTasksRewardFullSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTasksRewardFullSchemaPages as json.
func (s DataPageTasksRewardFullSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageTasksRewardFullSchemaPages:
		e.Int(s.Int)
	case NullDataPageTasksRewardFullSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageTasksRewardFullSchemaPages from json.
func (s *DataPageTasksRewardFullSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTasksRewardFullSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageTasksRewardFullSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageTasksRewardFullSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageTasksRewardFullSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTasksRewardFullSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTasksRewardFullSchemaSize as json.
func (s DataPageTasksRewardFullSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageTasksRewardFullSchemaSize:
		e.Int(s.Int)
	case NullDataPageTasksRewardFullSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageTasksRewardFullSchemaSize from json.
func (s *DataPageTasksRewardFullSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTasksRewardFullSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageTasksRewardFullSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageTasksRewardFullSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageTasksRewardFullSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTasksRewardFullSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTasksRewardFullSchemaTotal as json.
func (s DataPageTasksRewardFullSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageTasksRewardFullSchemaTotal:
		e.Int(s.Int)
	case NullDataPageTasksRewardFullSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageTasksRewardFullSchemaTotal from json.
func (s *DataPageTasksRewardFullSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTasksRewardFullSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageTasksRewardFullSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageTasksRewardFullSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageTasksRewardFullSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTasksRewardFullSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteCharacterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteCharacterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDeleteCharacterSchema = [1]string{
	0: "name",
}

// Decode decodes DeleteCharacterSchema from json.
func (s *DeleteCharacterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCharacterSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteCharacterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteCharacterSchema) {
					name = jsonFieldsNameOfDeleteCharacterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCharacterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCharacterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfDeleteItemResponseSchema = [1]string{
	0: "data",
}

// Decode decodes DeleteItemResponseSchema from json.
func (s *DeleteItemResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemResponseSchema) {
					name = jsonFieldsNameOfDeleteItemResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("item")
		s.Item.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfDeleteItemSchema = [3]string{
	0: "cooldown",
	1: "item",
	2: "character",
}

// Decode decodes DeleteItemSchema from json.
func (s *DeleteItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "item":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Item.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemSchema) {
					name = jsonFieldsNameOfDeleteItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDeleteItemSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes DeleteItemSchemaCharacter from json.
func (s *DeleteItemSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemSchemaCharacter) {
					name = jsonFieldsNameOfDeleteItemSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteItemSchemaCharacterSkin as json.
func (s DeleteItemSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeleteItemSchemaCharacterSkin from json.
func (s *DeleteItemSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeleteItemSchemaCharacterSkin(v) {
	case DeleteItemSchemaCharacterSkinMen1:
		*s = DeleteItemSchemaCharacterSkinMen1
	case DeleteItemSchemaCharacterSkinMen2:
		*s = DeleteItemSchemaCharacterSkinMen2
	case DeleteItemSchemaCharacterSkinMen3:
		*s = DeleteItemSchemaCharacterSkinMen3
	case DeleteItemSchemaCharacterSkinWomen1:
		*s = DeleteItemSchemaCharacterSkinWomen1
	case DeleteItemSchemaCharacterSkinWomen2:
		*s = DeleteItemSchemaCharacterSkinWomen2
	case DeleteItemSchemaCharacterSkinWomen3:
		*s = DeleteItemSchemaCharacterSkinWomen3
	default:
		*s = DeleteItemSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteItemSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfDeleteItemSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes DeleteItemSchemaCooldown from json.
func (s *DeleteItemSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemSchemaCooldown) {
					name = jsonFieldsNameOfDeleteItemSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteItemSchemaCooldownReason as json.
func (s DeleteItemSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeleteItemSchemaCooldownReason from json.
func (s *DeleteItemSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeleteItemSchemaCooldownReason(v) {
	case DeleteItemSchemaCooldownReasonMovement:
		*s = DeleteItemSchemaCooldownReasonMovement
	case DeleteItemSchemaCooldownReasonFight:
		*s = DeleteItemSchemaCooldownReasonFight
	case DeleteItemSchemaCooldownReasonCrafting:
		*s = DeleteItemSchemaCooldownReasonCrafting
	case DeleteItemSchemaCooldownReasonGathering:
		*s = DeleteItemSchemaCooldownReasonGathering
	case DeleteItemSchemaCooldownReasonBuyGe:
		*s = DeleteItemSchemaCooldownReasonBuyGe
	case DeleteItemSchemaCooldownReasonSellGe:
		*s = DeleteItemSchemaCooldownReasonSellGe
	case DeleteItemSchemaCooldownReasonDeleteItem:
		*s = DeleteItemSchemaCooldownReasonDeleteItem
	case DeleteItemSchemaCooldownReasonDepositBank:
		*s = DeleteItemSchemaCooldownReasonDepositBank
	case DeleteItemSchemaCooldownReasonWithdrawBank:
		*s = DeleteItemSchemaCooldownReasonWithdrawBank
	case DeleteItemSchemaCooldownReasonEquip:
		*s = DeleteItemSchemaCooldownReasonEquip
	case DeleteItemSchemaCooldownReasonUnequip:
		*s = DeleteItemSchemaCooldownReasonUnequip
	case DeleteItemSchemaCooldownReasonTask:
		*s = DeleteItemSchemaCooldownReasonTask
	case DeleteItemSchemaCooldownReasonRecycling:
		*s = DeleteItemSchemaCooldownReasonRecycling
	default:
		*s = DeleteItemSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteItemSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemSchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfDeleteItemSchemaItem = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes DeleteItemSchemaItem from json.
func (s *DeleteItemSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemSchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemSchemaItem) {
					name = jsonFieldsNameOfDeleteItemSchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DepositWithdrawGoldSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DepositWithdrawGoldSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfDepositWithdrawGoldSchema = [1]string{
	0: "quantity",
}

// Decode decodes DepositWithdrawGoldSchema from json.
func (s *DepositWithdrawGoldSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositWithdrawGoldSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quantity":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DepositWithdrawGoldSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDepositWithdrawGoldSchema) {
					name = jsonFieldsNameOfDepositWithdrawGoldSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DepositWithdrawGoldSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositWithdrawGoldSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DestinationSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DestinationSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfDestinationSchema = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes DestinationSchema from json.
func (s *DestinationSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DestinationSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DestinationSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDestinationSchema) {
					name = jsonFieldsNameOfDestinationSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DestinationSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DestinationSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DropRateSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DropRateSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("rate")
		e.Int(s.Rate)
	}
	{
		e.FieldStart("min_quantity")
		e.Int(s.MinQuantity)
	}
	{
		e.FieldStart("max_quantity")
		e.Int(s.MaxQuantity)
	}
}

var jsonFieldsNameOfDropRateSchema = [4]string{
	0: "code",
	1: "rate",
	2: "min_quantity",
	3: "max_quantity",
}

// Decode decodes DropRateSchema from json.
func (s *DropRateSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DropRateSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "rate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Rate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate\"")
			}
		case "min_quantity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MinQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_quantity\"")
			}
		case "max_quantity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.MaxQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DropRateSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDropRateSchema) {
					name = jsonFieldsNameOfDropRateSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DropRateSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DropRateSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DropSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DropSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfDropSchema = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes DropSchema from json.
func (s *DropSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DropSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DropSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDropSchema) {
					name = jsonFieldsNameOfDropSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DropSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DropSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipRequestSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipRequestSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("slot")
		s.Slot.Encode(e)
	}
	{
		e.FieldStart("item")
		s.Item.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfEquipRequestSchema = [4]string{
	0: "cooldown",
	1: "slot",
	2: "item",
	3: "character",
}

// Decode decodes EquipRequestSchema from json.
func (s *EquipRequestSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "slot":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Slot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slot\"")
			}
		case "item":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Item.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipRequestSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipRequestSchema) {
					name = jsonFieldsNameOfEquipRequestSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipRequestSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipRequestSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipRequestSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEquipRequestSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes EquipRequestSchemaCharacter from json.
func (s *EquipRequestSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipRequestSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipRequestSchemaCharacter) {
					name = jsonFieldsNameOfEquipRequestSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipRequestSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaCharacterSkin as json.
func (s EquipRequestSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EquipRequestSchemaCharacterSkin from json.
func (s *EquipRequestSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EquipRequestSchemaCharacterSkin(v) {
	case EquipRequestSchemaCharacterSkinMen1:
		*s = EquipRequestSchemaCharacterSkinMen1
	case EquipRequestSchemaCharacterSkinMen2:
		*s = EquipRequestSchemaCharacterSkinMen2
	case EquipRequestSchemaCharacterSkinMen3:
		*s = EquipRequestSchemaCharacterSkinMen3
	case EquipRequestSchemaCharacterSkinWomen1:
		*s = EquipRequestSchemaCharacterSkinWomen1
	case EquipRequestSchemaCharacterSkinWomen2:
		*s = EquipRequestSchemaCharacterSkinWomen2
	case EquipRequestSchemaCharacterSkinWomen3:
		*s = EquipRequestSchemaCharacterSkinWomen3
	default:
		*s = EquipRequestSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipRequestSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipRequestSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfEquipRequestSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes EquipRequestSchemaCooldown from json.
func (s *EquipRequestSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipRequestSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipRequestSchemaCooldown) {
					name = jsonFieldsNameOfEquipRequestSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipRequestSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaCooldownReason as json.
func (s EquipRequestSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EquipRequestSchemaCooldownReason from json.
func (s *EquipRequestSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EquipRequestSchemaCooldownReason(v) {
	case EquipRequestSchemaCooldownReasonMovement:
		*s = EquipRequestSchemaCooldownReasonMovement
	case EquipRequestSchemaCooldownReasonFight:
		*s = EquipRequestSchemaCooldownReasonFight
	case EquipRequestSchemaCooldownReasonCrafting:
		*s = EquipRequestSchemaCooldownReasonCrafting
	case EquipRequestSchemaCooldownReasonGathering:
		*s = EquipRequestSchemaCooldownReasonGathering
	case EquipRequestSchemaCooldownReasonBuyGe:
		*s = EquipRequestSchemaCooldownReasonBuyGe
	case EquipRequestSchemaCooldownReasonSellGe:
		*s = EquipRequestSchemaCooldownReasonSellGe
	case EquipRequestSchemaCooldownReasonDeleteItem:
		*s = EquipRequestSchemaCooldownReasonDeleteItem
	case EquipRequestSchemaCooldownReasonDepositBank:
		*s = EquipRequestSchemaCooldownReasonDepositBank
	case EquipRequestSchemaCooldownReasonWithdrawBank:
		*s = EquipRequestSchemaCooldownReasonWithdrawBank
	case EquipRequestSchemaCooldownReasonEquip:
		*s = EquipRequestSchemaCooldownReasonEquip
	case EquipRequestSchemaCooldownReasonUnequip:
		*s = EquipRequestSchemaCooldownReasonUnequip
	case EquipRequestSchemaCooldownReasonTask:
		*s = EquipRequestSchemaCooldownReasonTask
	case EquipRequestSchemaCooldownReasonRecycling:
		*s = EquipRequestSchemaCooldownReasonRecycling
	default:
		*s = EquipRequestSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipRequestSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipRequestSchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("subtype")
		e.Str(s.Subtype)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Craft.Set {
			e.FieldStart("craft")
			s.Craft.Encode(e)
		}
	}
}

var jsonFieldsNameOfEquipRequestSchemaItem = [8]string{
	0: "name",
	1: "code",
	2: "level",
	3: "type",
	4: "subtype",
	5: "description",
	6: "effects",
	7: "craft",
}

// Decode decodes EquipRequestSchemaItem from json.
func (s *EquipRequestSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "subtype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subtype = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtype\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]ItemEffectSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemEffectSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "craft":
			if err := func() error {
				s.Craft.Reset()
				if err := s.Craft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craft\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipRequestSchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipRequestSchemaItem) {
					name = jsonFieldsNameOfEquipRequestSchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipRequestSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaItemCraft as json.
func (s EquipRequestSchemaItemCraft) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaEquipRequestSchemaItemCraft:
		s.CraftSchema.Encode(e)
	case NullEquipRequestSchemaItemCraft:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes EquipRequestSchemaItemCraft from json.
func (s *EquipRequestSchemaItemCraft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaItemCraft to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullEquipRequestSchemaItemCraft
	case jx.Object:
		if err := s.CraftSchema.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaEquipRequestSchemaItemCraft
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaSlot as json.
func (s EquipRequestSchemaSlot) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EquipRequestSchemaSlot from json.
func (s *EquipRequestSchemaSlot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaSlot to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EquipRequestSchemaSlot(v) {
	case EquipRequestSchemaSlotWeapon:
		*s = EquipRequestSchemaSlotWeapon
	case EquipRequestSchemaSlotShield:
		*s = EquipRequestSchemaSlotShield
	case EquipRequestSchemaSlotHelmet:
		*s = EquipRequestSchemaSlotHelmet
	case EquipRequestSchemaSlotBodyArmor:
		*s = EquipRequestSchemaSlotBodyArmor
	case EquipRequestSchemaSlotLegArmor:
		*s = EquipRequestSchemaSlotLegArmor
	case EquipRequestSchemaSlotBoots:
		*s = EquipRequestSchemaSlotBoots
	case EquipRequestSchemaSlotRing1:
		*s = EquipRequestSchemaSlotRing1
	case EquipRequestSchemaSlotRing2:
		*s = EquipRequestSchemaSlotRing2
	case EquipRequestSchemaSlotAmulet:
		*s = EquipRequestSchemaSlotAmulet
	case EquipRequestSchemaSlotArtifact1:
		*s = EquipRequestSchemaSlotArtifact1
	case EquipRequestSchemaSlotArtifact2:
		*s = EquipRequestSchemaSlotArtifact2
	case EquipRequestSchemaSlotArtifact3:
		*s = EquipRequestSchemaSlotArtifact3
	case EquipRequestSchemaSlotConsumable1:
		*s = EquipRequestSchemaSlotConsumable1
	case EquipRequestSchemaSlotConsumable2:
		*s = EquipRequestSchemaSlotConsumable2
	default:
		*s = EquipRequestSchemaSlot(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaSlot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaSlot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("slot")
		s.Slot.Encode(e)
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfEquipSchema = [3]string{
	0: "code",
	1: "slot",
	2: "quantity",
}

// Decode decodes EquipSchema from json.
func (s *EquipSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipSchema to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "slot":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Slot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slot\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipSchema) {
					name = jsonFieldsNameOfEquipSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipSchemaSlot as json.
func (s EquipSchemaSlot) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EquipSchemaSlot from json.
func (s *EquipSchemaSlot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipSchemaSlot to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EquipSchemaSlot(v) {
	case EquipSchemaSlotWeapon:
		*s = EquipSchemaSlotWeapon
	case EquipSchemaSlotShield:
		*s = EquipSchemaSlotShield
	case EquipSchemaSlotHelmet:
		*s = EquipSchemaSlotHelmet
	case EquipSchemaSlotBodyArmor:
		*s = EquipSchemaSlotBodyArmor
	case EquipSchemaSlotLegArmor:
		*s = EquipSchemaSlotLegArmor
	case EquipSchemaSlotBoots:
		*s = EquipSchemaSlotBoots
	case EquipSchemaSlotRing1:
		*s = EquipSchemaSlotRing1
	case EquipSchemaSlotRing2:
		*s = EquipSchemaSlotRing2
	case EquipSchemaSlotAmulet:
		*s = EquipSchemaSlotAmulet
	case EquipSchemaSlotArtifact1:
		*s = EquipSchemaSlotArtifact1
	case EquipSchemaSlotArtifact2:
		*s = EquipSchemaSlotArtifact2
	case EquipSchemaSlotArtifact3:
		*s = EquipSchemaSlotArtifact3
	case EquipSchemaSlotConsumable1:
		*s = EquipSchemaSlotConsumable1
	case EquipSchemaSlotConsumable2:
		*s = EquipSchemaSlotConsumable2
	default:
		*s = EquipSchemaSlot(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipSchemaSlot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipSchemaSlot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipmentResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipmentResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfEquipmentResponseSchema = [1]string{
	0: "data",
}

// Decode decodes EquipmentResponseSchema from json.
func (s *EquipmentResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipmentResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipmentResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipmentResponseSchema) {
					name = jsonFieldsNameOfEquipmentResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipmentResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipmentResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GEItemResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GEItemResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGEItemResponseSchema = [1]string{
	0: "data",
}

// Decode decodes GEItemResponseSchema from json.
func (s *GEItemResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEItemResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GEItemResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGEItemResponseSchema) {
					name = jsonFieldsNameOfGEItemResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GEItemResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEItemResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GEItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GEItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("stock")
		e.Int(s.Stock)
	}
	{
		if s.SellPrice.Set {
			e.FieldStart("sell_price")
			s.SellPrice.Encode(e)
		}
	}
	{
		if s.BuyPrice.Set {
			e.FieldStart("buy_price")
			s.BuyPrice.Encode(e)
		}
	}
	{
		e.FieldStart("max_quantity")
		e.Int(s.MaxQuantity)
	}
}

var jsonFieldsNameOfGEItemSchema = [5]string{
	0: "code",
	1: "stock",
	2: "sell_price",
	3: "buy_price",
	4: "max_quantity",
}

// Decode decodes GEItemSchema from json.
func (s *GEItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "stock":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Stock = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stock\"")
			}
		case "sell_price":
			if err := func() error {
				s.SellPrice.Reset()
				if err := s.SellPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sell_price\"")
			}
		case "buy_price":
			if err := func() error {
				s.BuyPrice.Reset()
				if err := s.BuyPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buy_price\"")
			}
		case "max_quantity":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GEItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGEItemSchema) {
					name = jsonFieldsNameOfGEItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GEItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
	{
		e.FieldStart("price")
		e.Int(s.Price)
	}
}

var jsonFieldsNameOfGETransactionItemSchema = [3]string{
	0: "code",
	1: "quantity",
	2: "price",
}

// Decode decodes GETransactionItemSchema from json.
func (s *GETransactionItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Price = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionItemSchema) {
					name = jsonFieldsNameOfGETransactionItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionListSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionListSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("transaction")
		s.Transaction.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfGETransactionListSchema = [3]string{
	0: "cooldown",
	1: "transaction",
	2: "character",
}

// Decode decodes GETransactionListSchema from json.
func (s *GETransactionListSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "transaction":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Transaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionListSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionListSchema) {
					name = jsonFieldsNameOfGETransactionListSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionListSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionListSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionListSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGETransactionListSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes GETransactionListSchemaCharacter from json.
func (s *GETransactionListSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionListSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionListSchemaCharacter) {
					name = jsonFieldsNameOfGETransactionListSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionListSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GETransactionListSchemaCharacterSkin as json.
func (s GETransactionListSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GETransactionListSchemaCharacterSkin from json.
func (s *GETransactionListSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GETransactionListSchemaCharacterSkin(v) {
	case GETransactionListSchemaCharacterSkinMen1:
		*s = GETransactionListSchemaCharacterSkinMen1
	case GETransactionListSchemaCharacterSkinMen2:
		*s = GETransactionListSchemaCharacterSkinMen2
	case GETransactionListSchemaCharacterSkinMen3:
		*s = GETransactionListSchemaCharacterSkinMen3
	case GETransactionListSchemaCharacterSkinWomen1:
		*s = GETransactionListSchemaCharacterSkinWomen1
	case GETransactionListSchemaCharacterSkinWomen2:
		*s = GETransactionListSchemaCharacterSkinWomen2
	case GETransactionListSchemaCharacterSkinWomen3:
		*s = GETransactionListSchemaCharacterSkinWomen3
	default:
		*s = GETransactionListSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GETransactionListSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionListSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionListSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfGETransactionListSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes GETransactionListSchemaCooldown from json.
func (s *GETransactionListSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionListSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionListSchemaCooldown) {
					name = jsonFieldsNameOfGETransactionListSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionListSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GETransactionListSchemaCooldownReason as json.
func (s GETransactionListSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GETransactionListSchemaCooldownReason from json.
func (s *GETransactionListSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GETransactionListSchemaCooldownReason(v) {
	case GETransactionListSchemaCooldownReasonMovement:
		*s = GETransactionListSchemaCooldownReasonMovement
	case GETransactionListSchemaCooldownReasonFight:
		*s = GETransactionListSchemaCooldownReasonFight
	case GETransactionListSchemaCooldownReasonCrafting:
		*s = GETransactionListSchemaCooldownReasonCrafting
	case GETransactionListSchemaCooldownReasonGathering:
		*s = GETransactionListSchemaCooldownReasonGathering
	case GETransactionListSchemaCooldownReasonBuyGe:
		*s = GETransactionListSchemaCooldownReasonBuyGe
	case GETransactionListSchemaCooldownReasonSellGe:
		*s = GETransactionListSchemaCooldownReasonSellGe
	case GETransactionListSchemaCooldownReasonDeleteItem:
		*s = GETransactionListSchemaCooldownReasonDeleteItem
	case GETransactionListSchemaCooldownReasonDepositBank:
		*s = GETransactionListSchemaCooldownReasonDepositBank
	case GETransactionListSchemaCooldownReasonWithdrawBank:
		*s = GETransactionListSchemaCooldownReasonWithdrawBank
	case GETransactionListSchemaCooldownReasonEquip:
		*s = GETransactionListSchemaCooldownReasonEquip
	case GETransactionListSchemaCooldownReasonUnequip:
		*s = GETransactionListSchemaCooldownReasonUnequip
	case GETransactionListSchemaCooldownReasonTask:
		*s = GETransactionListSchemaCooldownReasonTask
	case GETransactionListSchemaCooldownReasonRecycling:
		*s = GETransactionListSchemaCooldownReasonRecycling
	default:
		*s = GETransactionListSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GETransactionListSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionListSchemaTransaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionListSchemaTransaction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
	{
		e.FieldStart("price")
		e.Int(s.Price)
	}
	{
		e.FieldStart("total_price")
		e.Int(s.TotalPrice)
	}
}

var jsonFieldsNameOfGETransactionListSchemaTransaction = [4]string{
	0: "code",
	1: "quantity",
	2: "price",
	3: "total_price",
}

// Decode decodes GETransactionListSchemaTransaction from json.
func (s *GETransactionListSchemaTransaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaTransaction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Price = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "total_price":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalPrice = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionListSchemaTransaction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionListSchemaTransaction) {
					name = jsonFieldsNameOfGETransactionListSchemaTransaction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionListSchemaTransaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaTransaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGETransactionResponseSchema = [1]string{
	0: "data",
}

// Decode decodes GETransactionResponseSchema from json.
func (s *GETransactionResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionResponseSchema) {
					name = jsonFieldsNameOfGETransactionResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InventorySlot) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InventorySlot) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("slot")
		e.Int(s.Slot)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfInventorySlot = [3]string{
	0: "slot",
	1: "code",
	2: "quantity",
}

// Decode decodes InventorySlot from json.
func (s *InventorySlot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InventorySlot to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slot":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Slot = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slot\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InventorySlot")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInventorySlot) {
					name = jsonFieldsNameOfInventorySlot[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InventorySlot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InventorySlot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ItemEffectSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ItemEffectSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Int(s.Value)
	}
}

var jsonFieldsNameOfItemEffectSchema = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes ItemEffectSchema from json.
func (s *ItemEffectSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemEffectSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Value = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ItemEffectSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfItemEffectSchema) {
					name = jsonFieldsNameOfItemEffectSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ItemEffectSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemEffectSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ItemResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ItemResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfItemResponseSchema = [1]string{
	0: "data",
}

// Decode decodes ItemResponseSchema from json.
func (s *ItemResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ItemResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfItemResponseSchema) {
					name = jsonFieldsNameOfItemResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ItemResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("subtype")
		e.Str(s.Subtype)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Craft.Set {
			e.FieldStart("craft")
			s.Craft.Encode(e)
		}
	}
}

var jsonFieldsNameOfItemSchema = [8]string{
	0: "name",
	1: "code",
	2: "level",
	3: "type",
	4: "subtype",
	5: "description",
	6: "effects",
	7: "craft",
}

// Decode decodes ItemSchema from json.
func (s *ItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "subtype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subtype = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtype\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]ItemEffectSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemEffectSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "craft":
			if err := func() error {
				s.Craft.Reset()
				if err := s.Craft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craft\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfItemSchema) {
					name = jsonFieldsNameOfItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ItemSchemaCraft as json.
func (s ItemSchemaCraft) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaItemSchemaCraft:
		s.CraftSchema.Encode(e)
	case NullItemSchemaCraft:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes ItemSchemaCraft from json.
func (s *ItemSchemaCraft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemSchemaCraft to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullItemSchemaCraft
	case jx.Object:
		if err := s.CraftSchema.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaItemSchemaCraft
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ItemSchemaCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemSchemaCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LogSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LogSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character")
		e.Str(s.Character)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if len(s.Content) != 0 {
			e.FieldStart("content")
			e.Raw(s.Content)
		}
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		e.FieldStart("cooldown_expiration")
		s.CooldownExpiration.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
}

var jsonFieldsNameOfLogSchema = [8]string{
	0: "character",
	1: "account",
	2: "type",
	3: "description",
	4: "content",
	5: "cooldown",
	6: "cooldown_expiration",
	7: "created_at",
}

// Decode decodes LogSchema from json.
func (s *LogSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Character = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Content = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "cooldown":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LogSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLogSchema) {
					name = jsonFieldsNameOfLogSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LogSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LogSchemaCooldownExpiration as json.
func (s LogSchemaCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeLogSchemaCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullLogSchemaCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes LogSchemaCooldownExpiration from json.
func (s *LogSchemaCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogSchemaCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullLogSchemaCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeLogSchemaCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LogSchemaCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogSchemaCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MapContentSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MapContentSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
}

var jsonFieldsNameOfMapContentSchema = [2]string{
	0: "type",
	1: "code",
}

// Decode decodes MapContentSchema from json.
func (s *MapContentSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapContentSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MapContentSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMapContentSchema) {
					name = jsonFieldsNameOfMapContentSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MapContentSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapContentSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MapResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MapResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfMapResponseSchema = [1]string{
	0: "data",
}

// Decode decodes MapResponseSchema from json.
func (s *MapResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MapResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMapResponseSchema) {
					name = jsonFieldsNameOfMapResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MapResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MapSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MapSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		e.Str(s.Skin)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfMapSchema = [5]string{
	0: "name",
	1: "skin",
	2: "x",
	3: "y",
	4: "content",
}

// Decode decodes MapSchema from json.
func (s *MapSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Skin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "x":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MapSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMapSchema) {
					name = jsonFieldsNameOfMapSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MapSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MapSchemaContent as json.
func (s MapSchemaContent) Encode(e *jx.Encoder) {
	switch s.Type {
	case MapContentSchemaMapSchemaContent:
		s.MapContentSchema.Encode(e)
	case NullMapSchemaContent:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes MapSchemaContent from json.
func (s *MapSchemaContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapSchemaContent to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullMapSchemaContent
	case jx.Object:
		if err := s.MapContentSchema.Decode(d); err != nil {
			return err
		}
		s.Type = MapContentSchemaMapSchemaContent
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MapSchemaContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapSchemaContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MonsterResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MonsterResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfMonsterResponseSchema = [1]string{
	0: "data",
}

// Decode decodes MonsterResponseSchema from json.
func (s *MonsterResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MonsterResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MonsterResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMonsterResponseSchema) {
					name = jsonFieldsNameOfMonsterResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MonsterResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MonsterResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MonsterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MonsterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("min_gold")
		e.Int(s.MinGold)
	}
	{
		e.FieldStart("max_gold")
		e.Int(s.MaxGold)
	}
	{
		e.FieldStart("drops")
		e.ArrStart()
		for _, elem := range s.Drops {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMonsterSchema = [15]string{
	0:  "name",
	1:  "code",
	2:  "level",
	3:  "hp",
	4:  "attack_fire",
	5:  "attack_earth",
	6:  "attack_water",
	7:  "attack_air",
	8:  "res_fire",
	9:  "res_earth",
	10: "res_water",
	11: "res_air",
	12: "min_gold",
	13: "max_gold",
	14: "drops",
}

// Decode decodes MonsterSchema from json.
func (s *MonsterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MonsterSchema to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "hp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "attack_fire":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "res_fire":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "min_gold":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MinGold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_gold\"")
			}
		case "max_gold":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxGold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_gold\"")
			}
		case "drops":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				s.Drops = make([]DropRateSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropRateSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Drops = append(s.Drops, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drops\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MonsterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMonsterSchema) {
					name = jsonFieldsNameOfMonsterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MonsterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MonsterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MyCharactersListSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MyCharactersListSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMyCharactersListSchema = [1]string{
	0: "data",
}

// Decode decodes MyCharactersListSchema from json.
func (s *MyCharactersListSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MyCharactersListSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]CharacterSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CharacterSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MyCharactersListSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMyCharactersListSchema) {
					name = jsonFieldsNameOfMyCharactersListSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MyCharactersListSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MyCharactersListSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemTransactionSchemaItemCraft as json.
func (o OptBankItemTransactionSchemaItemCraft) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BankItemTransactionSchemaItemCraft from json.
func (o *OptBankItemTransactionSchemaItemCraft) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBankItemTransactionSchemaItemCraft to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBankItemTransactionSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBankItemTransactionSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CraftSchemaSkill as json.
func (o OptCraftSchemaSkill) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CraftSchemaSkill from json.
func (o *OptCraftSchemaSkill) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCraftSchemaSkill to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCraftSchemaSkill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCraftSchemaSkill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAchievementSchemaPages as json.
func (o OptDataPageAchievementSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageAchievementSchemaPages from json.
func (o *OptDataPageAchievementSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageAchievementSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageAchievementSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageAchievementSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageActiveEventSchemaPages as json.
func (o OptDataPageActiveEventSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageActiveEventSchemaPages from json.
func (o *OptDataPageActiveEventSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageActiveEventSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageActiveEventSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageActiveEventSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageBaseAchievementSchemaPages as json.
func (o OptDataPageBaseAchievementSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageBaseAchievementSchemaPages from json.
func (o *OptDataPageBaseAchievementSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageBaseAchievementSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageBaseAchievementSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageBaseAchievementSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterLeaderboardSchemaPages as json.
func (o OptDataPageCharacterLeaderboardSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageCharacterLeaderboardSchemaPages from json.
func (o *OptDataPageCharacterLeaderboardSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageCharacterLeaderboardSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageCharacterLeaderboardSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageCharacterLeaderboardSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterSchemaPages as json.
func (o OptDataPageCharacterSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageCharacterSchemaPages from json.
func (o *OptDataPageCharacterSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageCharacterSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageCharacterSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageCharacterSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEItemSchemaPages as json.
func (o OptDataPageGEItemSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageGEItemSchemaPages from json.
func (o *OptDataPageGEItemSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageGEItemSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageGEItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageGEItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaPages as json.
func (o OptDataPageItemSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageItemSchemaPages from json.
func (o *OptDataPageItemSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageItemSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaPages as json.
func (o OptDataPageLogSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageLogSchemaPages from json.
func (o *OptDataPageLogSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageLogSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageLogSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageLogSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaPages as json.
func (o OptDataPageMapSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageMapSchemaPages from json.
func (o *OptDataPageMapSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageMapSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageMapSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageMapSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaPages as json.
func (o OptDataPageMonsterSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageMonsterSchemaPages from json.
func (o *OptDataPageMonsterSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageMonsterSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageMonsterSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageMonsterSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaPages as json.
func (o OptDataPageResourceSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageResourceSchemaPages from json.
func (o *OptDataPageResourceSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageResourceSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageResourceSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageResourceSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaPages as json.
func (o OptDataPageSimpleItemSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageSimpleItemSchemaPages from json.
func (o *OptDataPageSimpleItemSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageSimpleItemSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageSimpleItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageSimpleItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTaskFullSchemaPages as json.
func (o OptDataPageTaskFullSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageTaskFullSchemaPages from json.
func (o *OptDataPageTaskFullSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageTaskFullSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageTaskFullSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageTaskFullSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTasksRewardFullSchemaPages as json.
func (o OptDataPageTasksRewardFullSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageTasksRewardFullSchemaPages from json.
func (o *OptDataPageTasksRewardFullSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageTasksRewardFullSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageTasksRewardFullSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageTasksRewardFullSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes EquipRequestSchemaItemCraft as json.
func (o OptEquipRequestSchemaItemCraft) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EquipRequestSchemaItemCraft from json.
func (o *OptEquipRequestSchemaItemCraft) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEquipRequestSchemaItemCraft to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEquipRequestSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEquipRequestSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ItemSchemaCraft as json.
func (o OptItemSchemaCraft) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ItemSchemaCraft from json.
func (o *OptItemSchemaCraft) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptItemSchemaCraft to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptItemSchemaCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptItemSchemaCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SingleItemSchemaGe as json.
func (o OptSingleItemSchemaGe) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SingleItemSchemaGe from json.
func (o *OptSingleItemSchemaGe) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSingleItemSchemaGe to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSingleItemSchemaGe) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSingleItemSchemaGe) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SingleItemSchemaItemCraft as json.
func (o OptSingleItemSchemaItemCraft) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SingleItemSchemaItemCraft from json.
func (o *OptSingleItemSchemaItemCraft) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSingleItemSchemaItemCraft to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSingleItemSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSingleItemSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("details")
		s.Details.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfRecyclingDataSchema = [3]string{
	0: "cooldown",
	1: "details",
	2: "character",
}

// Decode decodes RecyclingDataSchema from json.
func (s *RecyclingDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "details":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingDataSchema) {
					name = jsonFieldsNameOfRecyclingDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRecyclingDataSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes RecyclingDataSchemaCharacter from json.
func (s *RecyclingDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingDataSchemaCharacter) {
					name = jsonFieldsNameOfRecyclingDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecyclingDataSchemaCharacterSkin as json.
func (s RecyclingDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecyclingDataSchemaCharacterSkin from json.
func (s *RecyclingDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecyclingDataSchemaCharacterSkin(v) {
	case RecyclingDataSchemaCharacterSkinMen1:
		*s = RecyclingDataSchemaCharacterSkinMen1
	case RecyclingDataSchemaCharacterSkinMen2:
		*s = RecyclingDataSchemaCharacterSkinMen2
	case RecyclingDataSchemaCharacterSkinMen3:
		*s = RecyclingDataSchemaCharacterSkinMen3
	case RecyclingDataSchemaCharacterSkinWomen1:
		*s = RecyclingDataSchemaCharacterSkinWomen1
	case RecyclingDataSchemaCharacterSkinWomen2:
		*s = RecyclingDataSchemaCharacterSkinWomen2
	case RecyclingDataSchemaCharacterSkinWomen3:
		*s = RecyclingDataSchemaCharacterSkinWomen3
	default:
		*s = RecyclingDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecyclingDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfRecyclingDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes RecyclingDataSchemaCooldown from json.
func (s *RecyclingDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingDataSchemaCooldown) {
					name = jsonFieldsNameOfRecyclingDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecyclingDataSchemaCooldownReason as json.
func (s RecyclingDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecyclingDataSchemaCooldownReason from json.
func (s *RecyclingDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecyclingDataSchemaCooldownReason(v) {
	case RecyclingDataSchemaCooldownReasonMovement:
		*s = RecyclingDataSchemaCooldownReasonMovement
	case RecyclingDataSchemaCooldownReasonFight:
		*s = RecyclingDataSchemaCooldownReasonFight
	case RecyclingDataSchemaCooldownReasonCrafting:
		*s = RecyclingDataSchemaCooldownReasonCrafting
	case RecyclingDataSchemaCooldownReasonGathering:
		*s = RecyclingDataSchemaCooldownReasonGathering
	case RecyclingDataSchemaCooldownReasonBuyGe:
		*s = RecyclingDataSchemaCooldownReasonBuyGe
	case RecyclingDataSchemaCooldownReasonSellGe:
		*s = RecyclingDataSchemaCooldownReasonSellGe
	case RecyclingDataSchemaCooldownReasonDeleteItem:
		*s = RecyclingDataSchemaCooldownReasonDeleteItem
	case RecyclingDataSchemaCooldownReasonDepositBank:
		*s = RecyclingDataSchemaCooldownReasonDepositBank
	case RecyclingDataSchemaCooldownReasonWithdrawBank:
		*s = RecyclingDataSchemaCooldownReasonWithdrawBank
	case RecyclingDataSchemaCooldownReasonEquip:
		*s = RecyclingDataSchemaCooldownReasonEquip
	case RecyclingDataSchemaCooldownReasonUnequip:
		*s = RecyclingDataSchemaCooldownReasonUnequip
	case RecyclingDataSchemaCooldownReasonTask:
		*s = RecyclingDataSchemaCooldownReasonTask
	case RecyclingDataSchemaCooldownReasonRecycling:
		*s = RecyclingDataSchemaCooldownReasonRecycling
	default:
		*s = RecyclingDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecyclingDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingDataSchemaDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingDataSchemaDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRecyclingDataSchemaDetails = [1]string{
	0: "items",
}

// Decode decodes RecyclingDataSchemaDetails from json.
func (s *RecyclingDataSchemaDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]DropSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingDataSchemaDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingDataSchemaDetails) {
					name = jsonFieldsNameOfRecyclingDataSchemaDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingDataSchemaDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfRecyclingResponseSchema = [1]string{
	0: "data",
}

// Decode decodes RecyclingResponseSchema from json.
func (s *RecyclingResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingResponseSchema) {
					name = jsonFieldsNameOfRecyclingResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecyclingSchema = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes RecyclingSchema from json.
func (s *RecyclingSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingSchema to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingSchema) {
					name = jsonFieldsNameOfRecyclingSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfResourceResponseSchema = [1]string{
	0: "data",
}

// Decode decodes ResourceResponseSchema from json.
func (s *ResourceResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceResponseSchema) {
					name = jsonFieldsNameOfResourceResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("skill")
		s.Skill.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("drops")
		e.ArrStart()
		for _, elem := range s.Drops {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfResourceSchema = [5]string{
	0: "name",
	1: "code",
	2: "skill",
	3: "level",
	4: "drops",
}

// Decode decodes ResourceSchema from json.
func (s *ResourceSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "skill":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "drops":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Drops = make([]DropRateSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropRateSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Drops = append(s.Drops, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drops\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceSchema) {
					name = jsonFieldsNameOfResourceSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceSchemaSkill as json.
func (s ResourceSchemaSkill) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResourceSchemaSkill from json.
func (s *ResourceSchemaSkill) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceSchemaSkill to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResourceSchemaSkill(v) {
	case ResourceSchemaSkillMining:
		*s = ResourceSchemaSkillMining
	case ResourceSchemaSkillWoodcutting:
		*s = ResourceSchemaSkillWoodcutting
	case ResourceSchemaSkillFishing:
		*s = ResourceSchemaSkillFishing
	default:
		*s = ResourceSchemaSkill(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceSchemaSkill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceSchemaSkill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfResponseSchema = [1]string{
	0: "message",
}

// Decode decodes ResponseSchema from json.
func (s *ResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResponseSchema) {
					name = jsonFieldsNameOfResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SimpleItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SimpleItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfSimpleItemSchema = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes SimpleItemSchema from json.
func (s *SimpleItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleItemSchema) {
					name = jsonFieldsNameOfSimpleItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SimpleItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SimpleItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SingleItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SingleItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("item")
		s.Item.Encode(e)
	}
	{
		if s.Ge.Set {
			e.FieldStart("ge")
			s.Ge.Encode(e)
		}
	}
}

var jsonFieldsNameOfSingleItemSchema = [2]string{
	0: "item",
	1: "ge",
}

// Decode decodes SingleItemSchema from json.
func (s *SingleItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SingleItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Item.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item\"")
			}
		case "ge":
			if err := func() error {
				s.Ge.Reset()
				if err := s.Ge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ge\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SingleItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSingleItemSchema) {
					name = jsonFieldsNameOfSingleItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SingleItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SingleItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SingleItemSchemaGe as json.
func (s SingleItemSchemaGe) Encode(e *jx.Encoder) {
	switch s.Type {
	case GEItemSchemaSingleItemSchemaGe:
		s.GEItemSchema.Encode(e)
	case NullSingleItemSchemaGe:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes SingleItemSchemaGe from json.
func (s *SingleItemSchemaGe) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SingleItemSchemaGe to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullSingleItemSchemaGe
	case jx.Object:
		if err := s.GEItemSchema.Decode(d); err != nil {
			return err
		}
		s.Type = GEItemSchemaSingleItemSchemaGe
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SingleItemSchemaGe) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SingleItemSchemaGe) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SingleItemSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SingleItemSchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("subtype")
		e.Str(s.Subtype)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Craft.Set {
			e.FieldStart("craft")
			s.Craft.Encode(e)
		}
	}
}

var jsonFieldsNameOfSingleItemSchemaItem = [8]string{
	0: "name",
	1: "code",
	2: "level",
	3: "type",
	4: "subtype",
	5: "description",
	6: "effects",
	7: "craft",
}

// Decode decodes SingleItemSchemaItem from json.
func (s *SingleItemSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SingleItemSchemaItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "subtype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subtype = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtype\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]ItemEffectSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemEffectSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "craft":
			if err := func() error {
				s.Craft.Reset()
				if err := s.Craft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craft\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SingleItemSchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSingleItemSchemaItem) {
					name = jsonFieldsNameOfSingleItemSchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SingleItemSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SingleItemSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SingleItemSchemaItemCraft as json.
func (s SingleItemSchemaItemCraft) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaSingleItemSchemaItemCraft:
		s.CraftSchema.Encode(e)
	case NullSingleItemSchemaItemCraft:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes SingleItemSchemaItemCraft from json.
func (s *SingleItemSchemaItemCraft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SingleItemSchemaItemCraft to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullSingleItemSchemaItemCraft
	case jx.Object:
		if err := s.CraftSchema.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaSingleItemSchemaItemCraft
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SingleItemSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SingleItemSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("details")
		s.Details.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfSkillDataSchema = [3]string{
	0: "cooldown",
	1: "details",
	2: "character",
}

// Decode decodes SkillDataSchema from json.
func (s *SkillDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "details":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillDataSchema) {
					name = jsonFieldsNameOfSkillDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSkillDataSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes SkillDataSchemaCharacter from json.
func (s *SkillDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillDataSchemaCharacter) {
					name = jsonFieldsNameOfSkillDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkillDataSchemaCharacterSkin as json.
func (s SkillDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SkillDataSchemaCharacterSkin from json.
func (s *SkillDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SkillDataSchemaCharacterSkin(v) {
	case SkillDataSchemaCharacterSkinMen1:
		*s = SkillDataSchemaCharacterSkinMen1
	case SkillDataSchemaCharacterSkinMen2:
		*s = SkillDataSchemaCharacterSkinMen2
	case SkillDataSchemaCharacterSkinMen3:
		*s = SkillDataSchemaCharacterSkinMen3
	case SkillDataSchemaCharacterSkinWomen1:
		*s = SkillDataSchemaCharacterSkinWomen1
	case SkillDataSchemaCharacterSkinWomen2:
		*s = SkillDataSchemaCharacterSkinWomen2
	case SkillDataSchemaCharacterSkinWomen3:
		*s = SkillDataSchemaCharacterSkinWomen3
	default:
		*s = SkillDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SkillDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfSkillDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes SkillDataSchemaCooldown from json.
func (s *SkillDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillDataSchemaCooldown) {
					name = jsonFieldsNameOfSkillDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkillDataSchemaCooldownReason as json.
func (s SkillDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SkillDataSchemaCooldownReason from json.
func (s *SkillDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SkillDataSchemaCooldownReason(v) {
	case SkillDataSchemaCooldownReasonMovement:
		*s = SkillDataSchemaCooldownReasonMovement
	case SkillDataSchemaCooldownReasonFight:
		*s = SkillDataSchemaCooldownReasonFight
	case SkillDataSchemaCooldownReasonCrafting:
		*s = SkillDataSchemaCooldownReasonCrafting
	case SkillDataSchemaCooldownReasonGathering:
		*s = SkillDataSchemaCooldownReasonGathering
	case SkillDataSchemaCooldownReasonBuyGe:
		*s = SkillDataSchemaCooldownReasonBuyGe
	case SkillDataSchemaCooldownReasonSellGe:
		*s = SkillDataSchemaCooldownReasonSellGe
	case SkillDataSchemaCooldownReasonDeleteItem:
		*s = SkillDataSchemaCooldownReasonDeleteItem
	case SkillDataSchemaCooldownReasonDepositBank:
		*s = SkillDataSchemaCooldownReasonDepositBank
	case SkillDataSchemaCooldownReasonWithdrawBank:
		*s = SkillDataSchemaCooldownReasonWithdrawBank
	case SkillDataSchemaCooldownReasonEquip:
		*s = SkillDataSchemaCooldownReasonEquip
	case SkillDataSchemaCooldownReasonUnequip:
		*s = SkillDataSchemaCooldownReasonUnequip
	case SkillDataSchemaCooldownReasonTask:
		*s = SkillDataSchemaCooldownReasonTask
	case SkillDataSchemaCooldownReasonRecycling:
		*s = SkillDataSchemaCooldownReasonRecycling
	default:
		*s = SkillDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SkillDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillDataSchemaDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillDataSchemaDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSkillDataSchemaDetails = [2]string{
	0: "xp",
	1: "items",
}

// Decode decodes SkillDataSchemaDetails from json.
func (s *SkillDataSchemaDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "xp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]DropSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillDataSchemaDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillDataSchemaDetails) {
					name = jsonFieldsNameOfSkillDataSchemaDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillDataSchemaDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfSkillResponseSchema = [1]string{
	0: "data",
}

// Decode decodes SkillResponseSchema from json.
func (s *SkillResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillResponseSchema) {
					name = jsonFieldsNameOfSkillResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StatusResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StatusResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfStatusResponseSchema = [1]string{
	0: "data",
}

// Decode decodes StatusResponseSchema from json.
func (s *StatusResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StatusResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StatusResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStatusResponseSchema) {
					name = jsonFieldsNameOfStatusResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StatusResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StatusResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StatusSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StatusSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		e.FieldStart("max_level")
		e.Int(s.MaxLevel)
	}
	{
		e.FieldStart("characters_online")
		e.Int(s.CharactersOnline)
	}
	{
		e.FieldStart("server_time")
		json.EncodeDateTime(e, s.ServerTime)
	}
	{
		e.FieldStart("announcements")
		e.ArrStart()
		for _, elem := range s.Announcements {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("last_wipe")
		e.Str(s.LastWipe)
	}
	{
		e.FieldStart("next_wipe")
		e.Str(s.NextWipe)
	}
}

var jsonFieldsNameOfStatusSchema = [8]string{
	0: "status",
	1: "version",
	2: "max_level",
	3: "characters_online",
	4: "server_time",
	5: "announcements",
	6: "last_wipe",
	7: "next_wipe",
}

// Decode decodes StatusSchema from json.
func (s *StatusSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StatusSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "max_level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MaxLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_level\"")
			}
		case "characters_online":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CharactersOnline = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characters_online\"")
			}
		case "server_time":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ServerTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_time\"")
			}
		case "announcements":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Announcements = make([]AnnouncementSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AnnouncementSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Announcements = append(s.Announcements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"announcements\"")
			}
		case "last_wipe":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.LastWipe = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_wipe\"")
			}
		case "next_wipe":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NextWipe = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_wipe\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StatusSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStatusSchema) {
					name = jsonFieldsNameOfStatusSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StatusSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StatusSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskCancelledResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskCancelledResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTaskCancelledResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TaskCancelledResponseSchema from json.
func (s *TaskCancelledResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskCancelledResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskCancelledResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskCancelledResponseSchema) {
					name = jsonFieldsNameOfTaskCancelledResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskCancelledResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskCancelledResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskCancelledSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskCancelledSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfTaskCancelledSchema = [2]string{
	0: "cooldown",
	1: "character",
}

// Decode decodes TaskCancelledSchema from json.
func (s *TaskCancelledSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskCancelledSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskCancelledSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskCancelledSchema) {
					name = jsonFieldsNameOfTaskCancelledSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskCancelledSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskCancelledSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskCancelledSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskCancelledSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTaskCancelledSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes TaskCancelledSchemaCharacter from json.
func (s *TaskCancelledSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskCancelledSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskCancelledSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskCancelledSchemaCharacter) {
					name = jsonFieldsNameOfTaskCancelledSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskCancelledSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskCancelledSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskCancelledSchemaCharacterSkin as json.
func (s TaskCancelledSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskCancelledSchemaCharacterSkin from json.
func (s *TaskCancelledSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskCancelledSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskCancelledSchemaCharacterSkin(v) {
	case TaskCancelledSchemaCharacterSkinMen1:
		*s = TaskCancelledSchemaCharacterSkinMen1
	case TaskCancelledSchemaCharacterSkinMen2:
		*s = TaskCancelledSchemaCharacterSkinMen2
	case TaskCancelledSchemaCharacterSkinMen3:
		*s = TaskCancelledSchemaCharacterSkinMen3
	case TaskCancelledSchemaCharacterSkinWomen1:
		*s = TaskCancelledSchemaCharacterSkinWomen1
	case TaskCancelledSchemaCharacterSkinWomen2:
		*s = TaskCancelledSchemaCharacterSkinWomen2
	case TaskCancelledSchemaCharacterSkinWomen3:
		*s = TaskCancelledSchemaCharacterSkinWomen3
	default:
		*s = TaskCancelledSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskCancelledSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskCancelledSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskCancelledSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskCancelledSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfTaskCancelledSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes TaskCancelledSchemaCooldown from json.
func (s *TaskCancelledSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskCancelledSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskCancelledSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskCancelledSchemaCooldown) {
					name = jsonFieldsNameOfTaskCancelledSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskCancelledSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskCancelledSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskCancelledSchemaCooldownReason as json.
func (s TaskCancelledSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskCancelledSchemaCooldownReason from json.
func (s *TaskCancelledSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskCancelledSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskCancelledSchemaCooldownReason(v) {
	case TaskCancelledSchemaCooldownReasonMovement:
		*s = TaskCancelledSchemaCooldownReasonMovement
	case TaskCancelledSchemaCooldownReasonFight:
		*s = TaskCancelledSchemaCooldownReasonFight
	case TaskCancelledSchemaCooldownReasonCrafting:
		*s = TaskCancelledSchemaCooldownReasonCrafting
	case TaskCancelledSchemaCooldownReasonGathering:
		*s = TaskCancelledSchemaCooldownReasonGathering
	case TaskCancelledSchemaCooldownReasonBuyGe:
		*s = TaskCancelledSchemaCooldownReasonBuyGe
	case TaskCancelledSchemaCooldownReasonSellGe:
		*s = TaskCancelledSchemaCooldownReasonSellGe
	case TaskCancelledSchemaCooldownReasonDeleteItem:
		*s = TaskCancelledSchemaCooldownReasonDeleteItem
	case TaskCancelledSchemaCooldownReasonDepositBank:
		*s = TaskCancelledSchemaCooldownReasonDepositBank
	case TaskCancelledSchemaCooldownReasonWithdrawBank:
		*s = TaskCancelledSchemaCooldownReasonWithdrawBank
	case TaskCancelledSchemaCooldownReasonEquip:
		*s = TaskCancelledSchemaCooldownReasonEquip
	case TaskCancelledSchemaCooldownReasonUnequip:
		*s = TaskCancelledSchemaCooldownReasonUnequip
	case TaskCancelledSchemaCooldownReasonTask:
		*s = TaskCancelledSchemaCooldownReasonTask
	case TaskCancelledSchemaCooldownReasonRecycling:
		*s = TaskCancelledSchemaCooldownReasonRecycling
	default:
		*s = TaskCancelledSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskCancelledSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskCancelledSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("task")
		s.Task.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfTaskDataSchema = [3]string{
	0: "cooldown",
	1: "task",
	2: "character",
}

// Decode decodes TaskDataSchema from json.
func (s *TaskDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "task":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Task.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchema) {
					name = jsonFieldsNameOfTaskDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTaskDataSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes TaskDataSchemaCharacter from json.
func (s *TaskDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchemaCharacter) {
					name = jsonFieldsNameOfTaskDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskDataSchemaCharacterSkin as json.
func (s TaskDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskDataSchemaCharacterSkin from json.
func (s *TaskDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskDataSchemaCharacterSkin(v) {
	case TaskDataSchemaCharacterSkinMen1:
		*s = TaskDataSchemaCharacterSkinMen1
	case TaskDataSchemaCharacterSkinMen2:
		*s = TaskDataSchemaCharacterSkinMen2
	case TaskDataSchemaCharacterSkinMen3:
		*s = TaskDataSchemaCharacterSkinMen3
	case TaskDataSchemaCharacterSkinWomen1:
		*s = TaskDataSchemaCharacterSkinWomen1
	case TaskDataSchemaCharacterSkinWomen2:
		*s = TaskDataSchemaCharacterSkinWomen2
	case TaskDataSchemaCharacterSkinWomen3:
		*s = TaskDataSchemaCharacterSkinWomen3
	default:
		*s = TaskDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfTaskDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes TaskDataSchemaCooldown from json.
func (s *TaskDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchemaCooldown) {
					name = jsonFieldsNameOfTaskDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskDataSchemaCooldownReason as json.
func (s TaskDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskDataSchemaCooldownReason from json.
func (s *TaskDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskDataSchemaCooldownReason(v) {
	case TaskDataSchemaCooldownReasonMovement:
		*s = TaskDataSchemaCooldownReasonMovement
	case TaskDataSchemaCooldownReasonFight:
		*s = TaskDataSchemaCooldownReasonFight
	case TaskDataSchemaCooldownReasonCrafting:
		*s = TaskDataSchemaCooldownReasonCrafting
	case TaskDataSchemaCooldownReasonGathering:
		*s = TaskDataSchemaCooldownReasonGathering
	case TaskDataSchemaCooldownReasonBuyGe:
		*s = TaskDataSchemaCooldownReasonBuyGe
	case TaskDataSchemaCooldownReasonSellGe:
		*s = TaskDataSchemaCooldownReasonSellGe
	case TaskDataSchemaCooldownReasonDeleteItem:
		*s = TaskDataSchemaCooldownReasonDeleteItem
	case TaskDataSchemaCooldownReasonDepositBank:
		*s = TaskDataSchemaCooldownReasonDepositBank
	case TaskDataSchemaCooldownReasonWithdrawBank:
		*s = TaskDataSchemaCooldownReasonWithdrawBank
	case TaskDataSchemaCooldownReasonEquip:
		*s = TaskDataSchemaCooldownReasonEquip
	case TaskDataSchemaCooldownReasonUnequip:
		*s = TaskDataSchemaCooldownReasonUnequip
	case TaskDataSchemaCooldownReasonTask:
		*s = TaskDataSchemaCooldownReasonTask
	case TaskDataSchemaCooldownReasonRecycling:
		*s = TaskDataSchemaCooldownReasonRecycling
	default:
		*s = TaskDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchemaTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchemaTask) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfTaskDataSchemaTask = [3]string{
	0: "code",
	1: "type",
	2: "total",
}

// Decode decodes TaskDataSchemaTask from json.
func (s *TaskDataSchemaTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaTask to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchemaTask")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchemaTask) {
					name = jsonFieldsNameOfTaskDataSchemaTask[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchemaTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskDataSchemaTaskType as json.
func (s TaskDataSchemaTaskType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskDataSchemaTaskType from json.
func (s *TaskDataSchemaTaskType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaTaskType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskDataSchemaTaskType(v) {
	case TaskDataSchemaTaskTypeMonsters:
		*s = TaskDataSchemaTaskTypeMonsters
	case TaskDataSchemaTaskTypeItems:
		*s = TaskDataSchemaTaskTypeItems
	default:
		*s = TaskDataSchemaTaskType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskDataSchemaTaskType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaTaskType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskFullResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskFullResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTaskFullResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TaskFullResponseSchema from json.
func (s *TaskFullResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskFullResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskFullResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskFullResponseSchema) {
					name = jsonFieldsNameOfTaskFullResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskFullResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskFullResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskFullSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskFullSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("min_quantity")
		e.Int(s.MinQuantity)
	}
	{
		e.FieldStart("max_quantity")
		e.Int(s.MaxQuantity)
	}
	{
		e.FieldStart("skill")
		s.Skill.Encode(e)
	}
}

var jsonFieldsNameOfTaskFullSchema = [6]string{
	0: "code",
	1: "level",
	2: "type",
	3: "min_quantity",
	4: "max_quantity",
	5: "skill",
}

// Decode decodes TaskFullSchema from json.
func (s *TaskFullSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskFullSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "min_quantity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.MinQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_quantity\"")
			}
		case "max_quantity":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_quantity\"")
			}
		case "skill":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Skill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskFullSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskFullSchema) {
					name = jsonFieldsNameOfTaskFullSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskFullSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskFullSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskFullSchemaSkill as json.
func (s TaskFullSchemaSkill) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringTaskFullSchemaSkill:
		e.Str(s.String)
	case NullTaskFullSchemaSkill:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes TaskFullSchemaSkill from json.
func (s *TaskFullSchemaSkill) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskFullSchemaSkill to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullTaskFullSchemaSkill
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringTaskFullSchemaSkill
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskFullSchemaSkill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskFullSchemaSkill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskFullSchemaType as json.
func (s TaskFullSchemaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskFullSchemaType from json.
func (s *TaskFullSchemaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskFullSchemaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskFullSchemaType(v) {
	case TaskFullSchemaTypeMonsters:
		*s = TaskFullSchemaTypeMonsters
	case TaskFullSchemaTypeItems:
		*s = TaskFullSchemaTypeItems
	default:
		*s = TaskFullSchemaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskFullSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskFullSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTaskResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TaskResponseSchema from json.
func (s *TaskResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskResponseSchema) {
					name = jsonFieldsNameOfTaskResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskTradeDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskTradeDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("trade")
		s.Trade.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfTaskTradeDataSchema = [3]string{
	0: "cooldown",
	1: "trade",
	2: "character",
}

// Decode decodes TaskTradeDataSchema from json.
func (s *TaskTradeDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "trade":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Trade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trade\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskTradeDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskTradeDataSchema) {
					name = jsonFieldsNameOfTaskTradeDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskTradeDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskTradeDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskTradeDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTaskTradeDataSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes TaskTradeDataSchemaCharacter from json.
func (s *TaskTradeDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeDataSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskTradeDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskTradeDataSchemaCharacter) {
					name = jsonFieldsNameOfTaskTradeDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskTradeDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskTradeDataSchemaCharacterSkin as json.
func (s TaskTradeDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskTradeDataSchemaCharacterSkin from json.
func (s *TaskTradeDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskTradeDataSchemaCharacterSkin(v) {
	case TaskTradeDataSchemaCharacterSkinMen1:
		*s = TaskTradeDataSchemaCharacterSkinMen1
	case TaskTradeDataSchemaCharacterSkinMen2:
		*s = TaskTradeDataSchemaCharacterSkinMen2
	case TaskTradeDataSchemaCharacterSkinMen3:
		*s = TaskTradeDataSchemaCharacterSkinMen3
	case TaskTradeDataSchemaCharacterSkinWomen1:
		*s = TaskTradeDataSchemaCharacterSkinWomen1
	case TaskTradeDataSchemaCharacterSkinWomen2:
		*s = TaskTradeDataSchemaCharacterSkinWomen2
	case TaskTradeDataSchemaCharacterSkinWomen3:
		*s = TaskTradeDataSchemaCharacterSkinWomen3
	default:
		*s = TaskTradeDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskTradeDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskTradeDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskTradeDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfTaskTradeDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes TaskTradeDataSchemaCooldown from json.
func (s *TaskTradeDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskTradeDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskTradeDataSchemaCooldown) {
					name = jsonFieldsNameOfTaskTradeDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskTradeDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskTradeDataSchemaCooldownReason as json.
func (s TaskTradeDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskTradeDataSchemaCooldownReason from json.
func (s *TaskTradeDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskTradeDataSchemaCooldownReason(v) {
	case TaskTradeDataSchemaCooldownReasonMovement:
		*s = TaskTradeDataSchemaCooldownReasonMovement
	case TaskTradeDataSchemaCooldownReasonFight:
		*s = TaskTradeDataSchemaCooldownReasonFight
	case TaskTradeDataSchemaCooldownReasonCrafting:
		*s = TaskTradeDataSchemaCooldownReasonCrafting
	case TaskTradeDataSchemaCooldownReasonGathering:
		*s = TaskTradeDataSchemaCooldownReasonGathering
	case TaskTradeDataSchemaCooldownReasonBuyGe:
		*s = TaskTradeDataSchemaCooldownReasonBuyGe
	case TaskTradeDataSchemaCooldownReasonSellGe:
		*s = TaskTradeDataSchemaCooldownReasonSellGe
	case TaskTradeDataSchemaCooldownReasonDeleteItem:
		*s = TaskTradeDataSchemaCooldownReasonDeleteItem
	case TaskTradeDataSchemaCooldownReasonDepositBank:
		*s = TaskTradeDataSchemaCooldownReasonDepositBank
	case TaskTradeDataSchemaCooldownReasonWithdrawBank:
		*s = TaskTradeDataSchemaCooldownReasonWithdrawBank
	case TaskTradeDataSchemaCooldownReasonEquip:
		*s = TaskTradeDataSchemaCooldownReasonEquip
	case TaskTradeDataSchemaCooldownReasonUnequip:
		*s = TaskTradeDataSchemaCooldownReasonUnequip
	case TaskTradeDataSchemaCooldownReasonTask:
		*s = TaskTradeDataSchemaCooldownReasonTask
	case TaskTradeDataSchemaCooldownReasonRecycling:
		*s = TaskTradeDataSchemaCooldownReasonRecycling
	default:
		*s = TaskTradeDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskTradeDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskTradeDataSchemaTrade) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskTradeDataSchemaTrade) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfTaskTradeDataSchemaTrade = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes TaskTradeDataSchemaTrade from json.
func (s *TaskTradeDataSchemaTrade) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeDataSchemaTrade to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskTradeDataSchemaTrade")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskTradeDataSchemaTrade) {
					name = jsonFieldsNameOfTaskTradeDataSchemaTrade[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskTradeDataSchemaTrade) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeDataSchemaTrade) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskTradeResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskTradeResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTaskTradeResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TaskTradeResponseSchema from json.
func (s *TaskTradeResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskTradeResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskTradeResponseSchema) {
					name = jsonFieldsNameOfTaskTradeResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskTradeResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("reward")
		s.Reward.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfTasksRewardDataSchema = [3]string{
	0: "cooldown",
	1: "reward",
	2: "character",
}

// Decode decodes TasksRewardDataSchema from json.
func (s *TasksRewardDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "reward":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Reward.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reward\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardDataSchema) {
					name = jsonFieldsNameOfTasksRewardDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTasksRewardDataSchemaCharacter = [71]string{
	0:  "name",
	1:  "skin",
	2:  "level",
	3:  "xp",
	4:  "max_xp",
	5:  "achievements_points",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "hp",
	30: "haste",
	31: "critical_strike",
	32: "stamina",
	33: "attack_fire",
	34: "attack_earth",
	35: "attack_water",
	36: "attack_air",
	37: "dmg_fire",
	38: "dmg_earth",
	39: "dmg_water",
	40: "dmg_air",
	41: "res_fire",
	42: "res_earth",
	43: "res_water",
	44: "res_air",
	45: "x",
	46: "y",
	47: "cooldown",
	48: "cooldown_expiration",
	49: "weapon_slot",
	50: "shield_slot",
	51: "helmet_slot",
	52: "body_armor_slot",
	53: "leg_armor_slot",
	54: "boots_slot",
	55: "ring1_slot",
	56: "ring2_slot",
	57: "amulet_slot",
	58: "artifact1_slot",
	59: "artifact2_slot",
	60: "artifact3_slot",
	61: "consumable1_slot",
	62: "consumable1_slot_quantity",
	63: "consumable2_slot",
	64: "consumable2_slot_quantity",
	65: "task",
	66: "task_type",
	67: "task_progress",
	68: "task_total",
	69: "inventory_max_items",
	70: "inventory",
}

// Decode decodes TasksRewardDataSchemaCharacter from json.
func (s *TasksRewardDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataSchemaCharacter to nil")
	}
	var requiredBitSet [9]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [9]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardDataSchemaCharacter) {
					name = jsonFieldsNameOfTasksRewardDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TasksRewardDataSchemaCharacterSkin as json.
func (s TasksRewardDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TasksRewardDataSchemaCharacterSkin from json.
func (s *TasksRewardDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TasksRewardDataSchemaCharacterSkin(v) {
	case TasksRewardDataSchemaCharacterSkinMen1:
		*s = TasksRewardDataSchemaCharacterSkinMen1
	case TasksRewardDataSchemaCharacterSkinMen2:
		*s = TasksRewardDataSchemaCharacterSkinMen2
	case TasksRewardDataSchemaCharacterSkinMen3:
		*s = TasksRewardDataSchemaCharacterSkinMen3
	case TasksRewardDataSchemaCharacterSkinWomen1:
		*s = TasksRewardDataSchemaCharacterSkinWomen1
	case TasksRewardDataSchemaCharacterSkinWomen2:
		*s = TasksRewardDataSchemaCharacterSkinWomen2
	case TasksRewardDataSchemaCharacterSkinWomen3:
		*s = TasksRewardDataSchemaCharacterSkinWomen3
	default:
		*s = TasksRewardDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TasksRewardDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfTasksRewardDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes TasksRewardDataSchemaCooldown from json.
func (s *TasksRewardDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardDataSchemaCooldown) {
					name = jsonFieldsNameOfTasksRewardDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TasksRewardDataSchemaCooldownReason as json.
func (s TasksRewardDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TasksRewardDataSchemaCooldownReason from json.
func (s *TasksRewardDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TasksRewardDataSchemaCooldownReason(v) {
	case TasksRewardDataSchemaCooldownReasonMovement:
		*s = TasksRewardDataSchemaCooldownReasonMovement
	case TasksRewardDataSchemaCooldownReasonFight:
		*s = TasksRewardDataSchemaCooldownReasonFight
	case TasksRewardDataSchemaCooldownReasonCrafting:
		*s = TasksRewardDataSchemaCooldownReasonCrafting
	case TasksRewardDataSchemaCooldownReasonGathering:
		*s = TasksRewardDataSchemaCooldownReasonGathering
	case TasksRewardDataSchemaCooldownReasonBuyGe:
		*s = TasksRewardDataSchemaCooldownReasonBuyGe
	case TasksRewardDataSchemaCooldownReasonSellGe:
		*s = TasksRewardDataSchemaCooldownReasonSellGe
	case TasksRewardDataSchemaCooldownReasonDeleteItem:
		*s = TasksRewardDataSchemaCooldownReasonDeleteItem
	case TasksRewardDataSchemaCooldownReasonDepositBank:
		*s = TasksRewardDataSchemaCooldownReasonDepositBank
	case TasksRewardDataSchemaCooldownReasonWithdrawBank:
		*s = TasksRewardDataSchemaCooldownReasonWithdrawBank
	case TasksRewardDataSchemaCooldownReasonEquip:
		*s = TasksRewardDataSchemaCooldownReasonEquip
	case TasksRewardDataSchemaCooldownReasonUnequip:
		*s = TasksRewardDataSchemaCooldownReasonUnequip
	case TasksRewardDataSchemaCooldownReasonTask:
		*s = TasksRewardDataSchemaCooldownReasonTask
	case TasksRewardDataSchemaCooldownReasonRecycling:
		*s = TasksRewardDataSchemaCooldownReasonRecycling
	default:
		*s = TasksRewardDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TasksRewardDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardDataSchemaReward) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardDataSchemaReward) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfTasksRewardDataSchemaReward = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes TasksRewardDataSchemaReward from json.
func (s *TasksRewardDataSchemaReward) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataSchemaReward to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardDataSchemaReward")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardDataSchemaReward) {
					name = jsonFieldsNameOfTasksRewardDataSchemaReward[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardDataSchemaReward) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataSchemaReward) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardFullResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardFullResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTasksRewardFullResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TasksRewardFullResponseSchema from json.
func (s *TasksRewardFullResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardFullResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardFullResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardFullResponseSchema) {
					name = jsonFieldsNameOfTasksRewardFullResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardFullResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardFullResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardFullSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardFullSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("min_quantity")
		e.Int(s.MinQuantity)
	}
	{
		e.FieldStart("max_quantity")
		e.Int(s.MaxQuantity)
	}
	{
		e.FieldStart("odds")
		e.Float64(s.Odds)
	}
}

var jsonFieldsNameOfTasksRewardFullSchema = [4]string{
	0: "code",
	1: "min_quantity",
	2: "max_quantity",
	3: "odds",
}

// Decode decodes TasksRewardFullSchema from json.
func (s *TasksRewardFullSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardFullSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "min_quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MinQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_quantity\"")
			}
		case "max_quantity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MaxQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_quantity\"")
			}
		case "odds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Odds = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"odds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardFullSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardFullSchema) {
					name = jsonFieldsNameOfTasksRewardFullSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardFullSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardFullSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTasksRewardResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TasksRewardResponseSchema from json.
func (s *TasksRewardResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardResponseSchema) {
					name = jsonFieldsNameOfTasksRewardResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TokenResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TokenResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
}

var jsonFieldsNameOfTokenResponseSchema = [1]string{
	0: "token",
}

// Decode decodes TokenResponseSchema from json.
func (s *TokenResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TokenResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTokenResponseSchema) {
					name = jsonFieldsNameOfTokenResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TokenResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnequipSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnequipSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("slot")
		s.Slot.Encode(e)
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnequipSchema = [2]string{
	0: "slot",
	1: "quantity",
}

// Decode decodes UnequipSchema from json.
func (s *UnequipSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnequipSchema to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slot":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Slot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slot\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnequipSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnequipSchema) {
					name = jsonFieldsNameOfUnequipSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnequipSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnequipSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnequipSchemaSlot as json.
func (s UnequipSchemaSlot) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UnequipSchemaSlot from json.
func (s *UnequipSchemaSlot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnequipSchemaSlot to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UnequipSchemaSlot(v) {
	case UnequipSchemaSlotWeapon:
		*s = UnequipSchemaSlotWeapon
	case UnequipSchemaSlotShield:
		*s = UnequipSchemaSlotShield
	case UnequipSchemaSlotHelmet:
		*s = UnequipSchemaSlotHelmet
	case UnequipSchemaSlotBodyArmor:
		*s = UnequipSchemaSlotBodyArmor
	case UnequipSchemaSlotLegArmor:
		*s = UnequipSchemaSlotLegArmor
	case UnequipSchemaSlotBoots:
		*s = UnequipSchemaSlotBoots
	case UnequipSchemaSlotRing1:
		*s = UnequipSchemaSlotRing1
	case UnequipSchemaSlotRing2:
		*s = UnequipSchemaSlotRing2
	case UnequipSchemaSlotAmulet:
		*s = UnequipSchemaSlotAmulet
	case UnequipSchemaSlotArtifact1:
		*s = UnequipSchemaSlotArtifact1
	case UnequipSchemaSlotArtifact2:
		*s = UnequipSchemaSlotArtifact2
	case UnequipSchemaSlotArtifact3:
		*s = UnequipSchemaSlotArtifact3
	case UnequipSchemaSlotConsumable1:
		*s = UnequipSchemaSlotConsumable1
	case UnequipSchemaSlotConsumable2:
		*s = UnequipSchemaSlotConsumable2
	default:
		*s = UnequipSchemaSlot(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnequipSchemaSlot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnequipSchemaSlot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
